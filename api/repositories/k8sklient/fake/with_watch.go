// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/watch"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type WithWatch struct {
	CreateStub        func(context.Context, client.Object, ...client.CreateOption) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.CreateOption
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(context.Context, client.Object, ...client.DeleteOption) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.DeleteOption
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAllOfStub        func(context.Context, client.Object, ...client.DeleteAllOfOption) error
	deleteAllOfMutex       sync.RWMutex
	deleteAllOfArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.DeleteAllOfOption
	}
	deleteAllOfReturns struct {
		result1 error
	}
	deleteAllOfReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(context.Context, client.ObjectKey, client.Object, ...client.GetOption) error
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 client.ObjectKey
		arg3 client.Object
		arg4 []client.GetOption
	}
	getReturns struct {
		result1 error
	}
	getReturnsOnCall map[int]struct {
		result1 error
	}
	GroupVersionKindForStub        func(runtime.Object) (schema.GroupVersionKind, error)
	groupVersionKindForMutex       sync.RWMutex
	groupVersionKindForArgsForCall []struct {
		arg1 runtime.Object
	}
	groupVersionKindForReturns struct {
		result1 schema.GroupVersionKind
		result2 error
	}
	groupVersionKindForReturnsOnCall map[int]struct {
		result1 schema.GroupVersionKind
		result2 error
	}
	IsObjectNamespacedStub        func(runtime.Object) (bool, error)
	isObjectNamespacedMutex       sync.RWMutex
	isObjectNamespacedArgsForCall []struct {
		arg1 runtime.Object
	}
	isObjectNamespacedReturns struct {
		result1 bool
		result2 error
	}
	isObjectNamespacedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListStub        func(context.Context, client.ObjectList, ...client.ListOption) error
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 context.Context
		arg2 client.ObjectList
		arg3 []client.ListOption
	}
	listReturns struct {
		result1 error
	}
	listReturnsOnCall map[int]struct {
		result1 error
	}
	PatchStub        func(context.Context, client.Object, client.Patch, ...client.PatchOption) error
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
		arg3 client.Patch
		arg4 []client.PatchOption
	}
	patchReturns struct {
		result1 error
	}
	patchReturnsOnCall map[int]struct {
		result1 error
	}
	RESTMapperStub        func() meta.RESTMapper
	rESTMapperMutex       sync.RWMutex
	rESTMapperArgsForCall []struct {
	}
	rESTMapperReturns struct {
		result1 meta.RESTMapper
	}
	rESTMapperReturnsOnCall map[int]struct {
		result1 meta.RESTMapper
	}
	SchemeStub        func() *runtime.Scheme
	schemeMutex       sync.RWMutex
	schemeArgsForCall []struct {
	}
	schemeReturns struct {
		result1 *runtime.Scheme
	}
	schemeReturnsOnCall map[int]struct {
		result1 *runtime.Scheme
	}
	StatusStub        func() client.SubResourceWriter
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 client.SubResourceWriter
	}
	statusReturnsOnCall map[int]struct {
		result1 client.SubResourceWriter
	}
	SubResourceStub        func(string) client.SubResourceClient
	subResourceMutex       sync.RWMutex
	subResourceArgsForCall []struct {
		arg1 string
	}
	subResourceReturns struct {
		result1 client.SubResourceClient
	}
	subResourceReturnsOnCall map[int]struct {
		result1 client.SubResourceClient
	}
	UpdateStub        func(context.Context, client.Object, ...client.UpdateOption) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.UpdateOption
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	WatchStub        func(context.Context, client.ObjectList, ...client.ListOption) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		arg1 context.Context
		arg2 client.ObjectList
		arg3 []client.ListOption
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *WithWatch) Create(arg1 context.Context, arg2 client.Object, arg3 ...client.CreateOption) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.CreateOption
	}{arg1, arg2, arg3})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *WithWatch) CreateCalls(stub func(context.Context, client.Object, ...client.CreateOption) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *WithWatch) CreateArgsForCall(i int) (context.Context, client.Object, []client.CreateOption) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *WithWatch) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) Delete(arg1 context.Context, arg2 client.Object, arg3 ...client.DeleteOption) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.DeleteOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *WithWatch) DeleteCalls(stub func(context.Context, client.Object, ...client.DeleteOption) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *WithWatch) DeleteArgsForCall(i int) (context.Context, client.Object, []client.DeleteOption) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *WithWatch) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) DeleteAllOf(arg1 context.Context, arg2 client.Object, arg3 ...client.DeleteAllOfOption) error {
	fake.deleteAllOfMutex.Lock()
	ret, specificReturn := fake.deleteAllOfReturnsOnCall[len(fake.deleteAllOfArgsForCall)]
	fake.deleteAllOfArgsForCall = append(fake.deleteAllOfArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.DeleteAllOfOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteAllOfStub
	fakeReturns := fake.deleteAllOfReturns
	fake.recordInvocation("DeleteAllOf", []interface{}{arg1, arg2, arg3})
	fake.deleteAllOfMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) DeleteAllOfCallCount() int {
	fake.deleteAllOfMutex.RLock()
	defer fake.deleteAllOfMutex.RUnlock()
	return len(fake.deleteAllOfArgsForCall)
}

func (fake *WithWatch) DeleteAllOfCalls(stub func(context.Context, client.Object, ...client.DeleteAllOfOption) error) {
	fake.deleteAllOfMutex.Lock()
	defer fake.deleteAllOfMutex.Unlock()
	fake.DeleteAllOfStub = stub
}

func (fake *WithWatch) DeleteAllOfArgsForCall(i int) (context.Context, client.Object, []client.DeleteAllOfOption) {
	fake.deleteAllOfMutex.RLock()
	defer fake.deleteAllOfMutex.RUnlock()
	argsForCall := fake.deleteAllOfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *WithWatch) DeleteAllOfReturns(result1 error) {
	fake.deleteAllOfMutex.Lock()
	defer fake.deleteAllOfMutex.Unlock()
	fake.DeleteAllOfStub = nil
	fake.deleteAllOfReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) DeleteAllOfReturnsOnCall(i int, result1 error) {
	fake.deleteAllOfMutex.Lock()
	defer fake.deleteAllOfMutex.Unlock()
	fake.DeleteAllOfStub = nil
	if fake.deleteAllOfReturnsOnCall == nil {
		fake.deleteAllOfReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAllOfReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) Get(arg1 context.Context, arg2 client.ObjectKey, arg3 client.Object, arg4 ...client.GetOption) error {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 client.ObjectKey
		arg3 client.Object
		arg4 []client.GetOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3, arg4})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *WithWatch) GetCalls(stub func(context.Context, client.ObjectKey, client.Object, ...client.GetOption) error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *WithWatch) GetArgsForCall(i int) (context.Context, client.ObjectKey, client.Object, []client.GetOption) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *WithWatch) GetReturns(result1 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) GetReturnsOnCall(i int, result1 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) GroupVersionKindFor(arg1 runtime.Object) (schema.GroupVersionKind, error) {
	fake.groupVersionKindForMutex.Lock()
	ret, specificReturn := fake.groupVersionKindForReturnsOnCall[len(fake.groupVersionKindForArgsForCall)]
	fake.groupVersionKindForArgsForCall = append(fake.groupVersionKindForArgsForCall, struct {
		arg1 runtime.Object
	}{arg1})
	stub := fake.GroupVersionKindForStub
	fakeReturns := fake.groupVersionKindForReturns
	fake.recordInvocation("GroupVersionKindFor", []interface{}{arg1})
	fake.groupVersionKindForMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *WithWatch) GroupVersionKindForCallCount() int {
	fake.groupVersionKindForMutex.RLock()
	defer fake.groupVersionKindForMutex.RUnlock()
	return len(fake.groupVersionKindForArgsForCall)
}

func (fake *WithWatch) GroupVersionKindForCalls(stub func(runtime.Object) (schema.GroupVersionKind, error)) {
	fake.groupVersionKindForMutex.Lock()
	defer fake.groupVersionKindForMutex.Unlock()
	fake.GroupVersionKindForStub = stub
}

func (fake *WithWatch) GroupVersionKindForArgsForCall(i int) runtime.Object {
	fake.groupVersionKindForMutex.RLock()
	defer fake.groupVersionKindForMutex.RUnlock()
	argsForCall := fake.groupVersionKindForArgsForCall[i]
	return argsForCall.arg1
}

func (fake *WithWatch) GroupVersionKindForReturns(result1 schema.GroupVersionKind, result2 error) {
	fake.groupVersionKindForMutex.Lock()
	defer fake.groupVersionKindForMutex.Unlock()
	fake.GroupVersionKindForStub = nil
	fake.groupVersionKindForReturns = struct {
		result1 schema.GroupVersionKind
		result2 error
	}{result1, result2}
}

func (fake *WithWatch) GroupVersionKindForReturnsOnCall(i int, result1 schema.GroupVersionKind, result2 error) {
	fake.groupVersionKindForMutex.Lock()
	defer fake.groupVersionKindForMutex.Unlock()
	fake.GroupVersionKindForStub = nil
	if fake.groupVersionKindForReturnsOnCall == nil {
		fake.groupVersionKindForReturnsOnCall = make(map[int]struct {
			result1 schema.GroupVersionKind
			result2 error
		})
	}
	fake.groupVersionKindForReturnsOnCall[i] = struct {
		result1 schema.GroupVersionKind
		result2 error
	}{result1, result2}
}

func (fake *WithWatch) IsObjectNamespaced(arg1 runtime.Object) (bool, error) {
	fake.isObjectNamespacedMutex.Lock()
	ret, specificReturn := fake.isObjectNamespacedReturnsOnCall[len(fake.isObjectNamespacedArgsForCall)]
	fake.isObjectNamespacedArgsForCall = append(fake.isObjectNamespacedArgsForCall, struct {
		arg1 runtime.Object
	}{arg1})
	stub := fake.IsObjectNamespacedStub
	fakeReturns := fake.isObjectNamespacedReturns
	fake.recordInvocation("IsObjectNamespaced", []interface{}{arg1})
	fake.isObjectNamespacedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *WithWatch) IsObjectNamespacedCallCount() int {
	fake.isObjectNamespacedMutex.RLock()
	defer fake.isObjectNamespacedMutex.RUnlock()
	return len(fake.isObjectNamespacedArgsForCall)
}

func (fake *WithWatch) IsObjectNamespacedCalls(stub func(runtime.Object) (bool, error)) {
	fake.isObjectNamespacedMutex.Lock()
	defer fake.isObjectNamespacedMutex.Unlock()
	fake.IsObjectNamespacedStub = stub
}

func (fake *WithWatch) IsObjectNamespacedArgsForCall(i int) runtime.Object {
	fake.isObjectNamespacedMutex.RLock()
	defer fake.isObjectNamespacedMutex.RUnlock()
	argsForCall := fake.isObjectNamespacedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *WithWatch) IsObjectNamespacedReturns(result1 bool, result2 error) {
	fake.isObjectNamespacedMutex.Lock()
	defer fake.isObjectNamespacedMutex.Unlock()
	fake.IsObjectNamespacedStub = nil
	fake.isObjectNamespacedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *WithWatch) IsObjectNamespacedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isObjectNamespacedMutex.Lock()
	defer fake.isObjectNamespacedMutex.Unlock()
	fake.IsObjectNamespacedStub = nil
	if fake.isObjectNamespacedReturnsOnCall == nil {
		fake.isObjectNamespacedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isObjectNamespacedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *WithWatch) List(arg1 context.Context, arg2 client.ObjectList, arg3 ...client.ListOption) error {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 context.Context
		arg2 client.ObjectList
		arg3 []client.ListOption
	}{arg1, arg2, arg3})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1, arg2, arg3})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *WithWatch) ListCalls(stub func(context.Context, client.ObjectList, ...client.ListOption) error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *WithWatch) ListArgsForCall(i int) (context.Context, client.ObjectList, []client.ListOption) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *WithWatch) ListReturns(result1 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) ListReturnsOnCall(i int, result1 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) Patch(arg1 context.Context, arg2 client.Object, arg3 client.Patch, arg4 ...client.PatchOption) error {
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
		arg3 client.Patch
		arg4 []client.PatchOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.PatchStub
	fakeReturns := fake.patchReturns
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3, arg4})
	fake.patchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *WithWatch) PatchCalls(stub func(context.Context, client.Object, client.Patch, ...client.PatchOption) error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = stub
}

func (fake *WithWatch) PatchArgsForCall(i int) (context.Context, client.Object, client.Patch, []client.PatchOption) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	argsForCall := fake.patchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *WithWatch) PatchReturns(result1 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) PatchReturnsOnCall(i int, result1 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) RESTMapper() meta.RESTMapper {
	fake.rESTMapperMutex.Lock()
	ret, specificReturn := fake.rESTMapperReturnsOnCall[len(fake.rESTMapperArgsForCall)]
	fake.rESTMapperArgsForCall = append(fake.rESTMapperArgsForCall, struct {
	}{})
	stub := fake.RESTMapperStub
	fakeReturns := fake.rESTMapperReturns
	fake.recordInvocation("RESTMapper", []interface{}{})
	fake.rESTMapperMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) RESTMapperCallCount() int {
	fake.rESTMapperMutex.RLock()
	defer fake.rESTMapperMutex.RUnlock()
	return len(fake.rESTMapperArgsForCall)
}

func (fake *WithWatch) RESTMapperCalls(stub func() meta.RESTMapper) {
	fake.rESTMapperMutex.Lock()
	defer fake.rESTMapperMutex.Unlock()
	fake.RESTMapperStub = stub
}

func (fake *WithWatch) RESTMapperReturns(result1 meta.RESTMapper) {
	fake.rESTMapperMutex.Lock()
	defer fake.rESTMapperMutex.Unlock()
	fake.RESTMapperStub = nil
	fake.rESTMapperReturns = struct {
		result1 meta.RESTMapper
	}{result1}
}

func (fake *WithWatch) RESTMapperReturnsOnCall(i int, result1 meta.RESTMapper) {
	fake.rESTMapperMutex.Lock()
	defer fake.rESTMapperMutex.Unlock()
	fake.RESTMapperStub = nil
	if fake.rESTMapperReturnsOnCall == nil {
		fake.rESTMapperReturnsOnCall = make(map[int]struct {
			result1 meta.RESTMapper
		})
	}
	fake.rESTMapperReturnsOnCall[i] = struct {
		result1 meta.RESTMapper
	}{result1}
}

func (fake *WithWatch) Scheme() *runtime.Scheme {
	fake.schemeMutex.Lock()
	ret, specificReturn := fake.schemeReturnsOnCall[len(fake.schemeArgsForCall)]
	fake.schemeArgsForCall = append(fake.schemeArgsForCall, struct {
	}{})
	stub := fake.SchemeStub
	fakeReturns := fake.schemeReturns
	fake.recordInvocation("Scheme", []interface{}{})
	fake.schemeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) SchemeCallCount() int {
	fake.schemeMutex.RLock()
	defer fake.schemeMutex.RUnlock()
	return len(fake.schemeArgsForCall)
}

func (fake *WithWatch) SchemeCalls(stub func() *runtime.Scheme) {
	fake.schemeMutex.Lock()
	defer fake.schemeMutex.Unlock()
	fake.SchemeStub = stub
}

func (fake *WithWatch) SchemeReturns(result1 *runtime.Scheme) {
	fake.schemeMutex.Lock()
	defer fake.schemeMutex.Unlock()
	fake.SchemeStub = nil
	fake.schemeReturns = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *WithWatch) SchemeReturnsOnCall(i int, result1 *runtime.Scheme) {
	fake.schemeMutex.Lock()
	defer fake.schemeMutex.Unlock()
	fake.SchemeStub = nil
	if fake.schemeReturnsOnCall == nil {
		fake.schemeReturnsOnCall = make(map[int]struct {
			result1 *runtime.Scheme
		})
	}
	fake.schemeReturnsOnCall[i] = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *WithWatch) Status() client.SubResourceWriter {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *WithWatch) StatusCalls(stub func() client.SubResourceWriter) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *WithWatch) StatusReturns(result1 client.SubResourceWriter) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 client.SubResourceWriter
	}{result1}
}

func (fake *WithWatch) StatusReturnsOnCall(i int, result1 client.SubResourceWriter) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 client.SubResourceWriter
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 client.SubResourceWriter
	}{result1}
}

func (fake *WithWatch) SubResource(arg1 string) client.SubResourceClient {
	fake.subResourceMutex.Lock()
	ret, specificReturn := fake.subResourceReturnsOnCall[len(fake.subResourceArgsForCall)]
	fake.subResourceArgsForCall = append(fake.subResourceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SubResourceStub
	fakeReturns := fake.subResourceReturns
	fake.recordInvocation("SubResource", []interface{}{arg1})
	fake.subResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) SubResourceCallCount() int {
	fake.subResourceMutex.RLock()
	defer fake.subResourceMutex.RUnlock()
	return len(fake.subResourceArgsForCall)
}

func (fake *WithWatch) SubResourceCalls(stub func(string) client.SubResourceClient) {
	fake.subResourceMutex.Lock()
	defer fake.subResourceMutex.Unlock()
	fake.SubResourceStub = stub
}

func (fake *WithWatch) SubResourceArgsForCall(i int) string {
	fake.subResourceMutex.RLock()
	defer fake.subResourceMutex.RUnlock()
	argsForCall := fake.subResourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *WithWatch) SubResourceReturns(result1 client.SubResourceClient) {
	fake.subResourceMutex.Lock()
	defer fake.subResourceMutex.Unlock()
	fake.SubResourceStub = nil
	fake.subResourceReturns = struct {
		result1 client.SubResourceClient
	}{result1}
}

func (fake *WithWatch) SubResourceReturnsOnCall(i int, result1 client.SubResourceClient) {
	fake.subResourceMutex.Lock()
	defer fake.subResourceMutex.Unlock()
	fake.SubResourceStub = nil
	if fake.subResourceReturnsOnCall == nil {
		fake.subResourceReturnsOnCall = make(map[int]struct {
			result1 client.SubResourceClient
		})
	}
	fake.subResourceReturnsOnCall[i] = struct {
		result1 client.SubResourceClient
	}{result1}
}

func (fake *WithWatch) Update(arg1 context.Context, arg2 client.Object, arg3 ...client.UpdateOption) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 client.Object
		arg3 []client.UpdateOption
	}{arg1, arg2, arg3})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *WithWatch) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *WithWatch) UpdateCalls(stub func(context.Context, client.Object, ...client.UpdateOption) error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *WithWatch) UpdateArgsForCall(i int) (context.Context, client.Object, []client.UpdateOption) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *WithWatch) UpdateReturns(result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) UpdateReturnsOnCall(i int, result1 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *WithWatch) Watch(arg1 context.Context, arg2 client.ObjectList, arg3 ...client.ListOption) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		arg1 context.Context
		arg2 client.ObjectList
		arg3 []client.ListOption
	}{arg1, arg2, arg3})
	stub := fake.WatchStub
	fakeReturns := fake.watchReturns
	fake.recordInvocation("Watch", []interface{}{arg1, arg2, arg3})
	fake.watchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *WithWatch) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *WithWatch) WatchCalls(stub func(context.Context, client.ObjectList, ...client.ListOption) (watch.Interface, error)) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *WithWatch) WatchArgsForCall(i int) (context.Context, client.ObjectList, []client.ListOption) {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	argsForCall := fake.watchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *WithWatch) WatchReturns(result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *WithWatch) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *WithWatch) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteAllOfMutex.RLock()
	defer fake.deleteAllOfMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.groupVersionKindForMutex.RLock()
	defer fake.groupVersionKindForMutex.RUnlock()
	fake.isObjectNamespacedMutex.RLock()
	defer fake.isObjectNamespacedMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.rESTMapperMutex.RLock()
	defer fake.rESTMapperMutex.RUnlock()
	fake.schemeMutex.RLock()
	defer fake.schemeMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.subResourceMutex.RLock()
	defer fake.subResourceMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *WithWatch) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.WithWatch = new(WithWatch)
