// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"code.cloudfoundry.org/korifi/controllers/webhooks"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
)

type UniqueClientObject struct {
	DeepCopyObjectStub        func() runtime.Object
	deepCopyObjectMutex       sync.RWMutex
	deepCopyObjectArgsForCall []struct {
	}
	deepCopyObjectReturns struct {
		result1 runtime.Object
	}
	deepCopyObjectReturnsOnCall map[int]struct {
		result1 runtime.Object
	}
	GetAnnotationsStub        func() map[string]string
	getAnnotationsMutex       sync.RWMutex
	getAnnotationsArgsForCall []struct {
	}
	getAnnotationsReturns struct {
		result1 map[string]string
	}
	getAnnotationsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	GetCreationTimestampStub        func() v1.Time
	getCreationTimestampMutex       sync.RWMutex
	getCreationTimestampArgsForCall []struct {
	}
	getCreationTimestampReturns struct {
		result1 v1.Time
	}
	getCreationTimestampReturnsOnCall map[int]struct {
		result1 v1.Time
	}
	GetDeletionGracePeriodSecondsStub        func() *int64
	getDeletionGracePeriodSecondsMutex       sync.RWMutex
	getDeletionGracePeriodSecondsArgsForCall []struct {
	}
	getDeletionGracePeriodSecondsReturns struct {
		result1 *int64
	}
	getDeletionGracePeriodSecondsReturnsOnCall map[int]struct {
		result1 *int64
	}
	GetDeletionTimestampStub        func() *v1.Time
	getDeletionTimestampMutex       sync.RWMutex
	getDeletionTimestampArgsForCall []struct {
	}
	getDeletionTimestampReturns struct {
		result1 *v1.Time
	}
	getDeletionTimestampReturnsOnCall map[int]struct {
		result1 *v1.Time
	}
	GetFinalizersStub        func() []string
	getFinalizersMutex       sync.RWMutex
	getFinalizersArgsForCall []struct {
	}
	getFinalizersReturns struct {
		result1 []string
	}
	getFinalizersReturnsOnCall map[int]struct {
		result1 []string
	}
	GetGenerateNameStub        func() string
	getGenerateNameMutex       sync.RWMutex
	getGenerateNameArgsForCall []struct {
	}
	getGenerateNameReturns struct {
		result1 string
	}
	getGenerateNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetGenerationStub        func() int64
	getGenerationMutex       sync.RWMutex
	getGenerationArgsForCall []struct {
	}
	getGenerationReturns struct {
		result1 int64
	}
	getGenerationReturnsOnCall map[int]struct {
		result1 int64
	}
	GetLabelsStub        func() map[string]string
	getLabelsMutex       sync.RWMutex
	getLabelsArgsForCall []struct {
	}
	getLabelsReturns struct {
		result1 map[string]string
	}
	getLabelsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	GetManagedFieldsStub        func() []v1.ManagedFieldsEntry
	getManagedFieldsMutex       sync.RWMutex
	getManagedFieldsArgsForCall []struct {
	}
	getManagedFieldsReturns struct {
		result1 []v1.ManagedFieldsEntry
	}
	getManagedFieldsReturnsOnCall map[int]struct {
		result1 []v1.ManagedFieldsEntry
	}
	GetNameStub        func() string
	getNameMutex       sync.RWMutex
	getNameArgsForCall []struct {
	}
	getNameReturns struct {
		result1 string
	}
	getNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetNamespaceStub        func() string
	getNamespaceMutex       sync.RWMutex
	getNamespaceArgsForCall []struct {
	}
	getNamespaceReturns struct {
		result1 string
	}
	getNamespaceReturnsOnCall map[int]struct {
		result1 string
	}
	GetObjectKindStub        func() schema.ObjectKind
	getObjectKindMutex       sync.RWMutex
	getObjectKindArgsForCall []struct {
	}
	getObjectKindReturns struct {
		result1 schema.ObjectKind
	}
	getObjectKindReturnsOnCall map[int]struct {
		result1 schema.ObjectKind
	}
	GetOwnerReferencesStub        func() []v1.OwnerReference
	getOwnerReferencesMutex       sync.RWMutex
	getOwnerReferencesArgsForCall []struct {
	}
	getOwnerReferencesReturns struct {
		result1 []v1.OwnerReference
	}
	getOwnerReferencesReturnsOnCall map[int]struct {
		result1 []v1.OwnerReference
	}
	GetResourceVersionStub        func() string
	getResourceVersionMutex       sync.RWMutex
	getResourceVersionArgsForCall []struct {
	}
	getResourceVersionReturns struct {
		result1 string
	}
	getResourceVersionReturnsOnCall map[int]struct {
		result1 string
	}
	GetSelfLinkStub        func() string
	getSelfLinkMutex       sync.RWMutex
	getSelfLinkArgsForCall []struct {
	}
	getSelfLinkReturns struct {
		result1 string
	}
	getSelfLinkReturnsOnCall map[int]struct {
		result1 string
	}
	GetUIDStub        func() types.UID
	getUIDMutex       sync.RWMutex
	getUIDArgsForCall []struct {
	}
	getUIDReturns struct {
		result1 types.UID
	}
	getUIDReturnsOnCall map[int]struct {
		result1 types.UID
	}
	SetAnnotationsStub        func(map[string]string)
	setAnnotationsMutex       sync.RWMutex
	setAnnotationsArgsForCall []struct {
		arg1 map[string]string
	}
	SetCreationTimestampStub        func(v1.Time)
	setCreationTimestampMutex       sync.RWMutex
	setCreationTimestampArgsForCall []struct {
		arg1 v1.Time
	}
	SetDeletionGracePeriodSecondsStub        func(*int64)
	setDeletionGracePeriodSecondsMutex       sync.RWMutex
	setDeletionGracePeriodSecondsArgsForCall []struct {
		arg1 *int64
	}
	SetDeletionTimestampStub        func(*v1.Time)
	setDeletionTimestampMutex       sync.RWMutex
	setDeletionTimestampArgsForCall []struct {
		arg1 *v1.Time
	}
	SetFinalizersStub        func([]string)
	setFinalizersMutex       sync.RWMutex
	setFinalizersArgsForCall []struct {
		arg1 []string
	}
	SetGenerateNameStub        func(string)
	setGenerateNameMutex       sync.RWMutex
	setGenerateNameArgsForCall []struct {
		arg1 string
	}
	SetGenerationStub        func(int64)
	setGenerationMutex       sync.RWMutex
	setGenerationArgsForCall []struct {
		arg1 int64
	}
	SetLabelsStub        func(map[string]string)
	setLabelsMutex       sync.RWMutex
	setLabelsArgsForCall []struct {
		arg1 map[string]string
	}
	SetManagedFieldsStub        func([]v1.ManagedFieldsEntry)
	setManagedFieldsMutex       sync.RWMutex
	setManagedFieldsArgsForCall []struct {
		arg1 []v1.ManagedFieldsEntry
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetNamespaceStub        func(string)
	setNamespaceMutex       sync.RWMutex
	setNamespaceArgsForCall []struct {
		arg1 string
	}
	SetOwnerReferencesStub        func([]v1.OwnerReference)
	setOwnerReferencesMutex       sync.RWMutex
	setOwnerReferencesArgsForCall []struct {
		arg1 []v1.OwnerReference
	}
	SetResourceVersionStub        func(string)
	setResourceVersionMutex       sync.RWMutex
	setResourceVersionArgsForCall []struct {
		arg1 string
	}
	SetSelfLinkStub        func(string)
	setSelfLinkMutex       sync.RWMutex
	setSelfLinkArgsForCall []struct {
		arg1 string
	}
	SetUIDStub        func(types.UID)
	setUIDMutex       sync.RWMutex
	setUIDArgsForCall []struct {
		arg1 types.UID
	}
	UniqueNameStub        func() string
	uniqueNameMutex       sync.RWMutex
	uniqueNameArgsForCall []struct {
	}
	uniqueNameReturns struct {
		result1 string
	}
	uniqueNameReturnsOnCall map[int]struct {
		result1 string
	}
	UniqueValidationErrorMessageStub        func() string
	uniqueValidationErrorMessageMutex       sync.RWMutex
	uniqueValidationErrorMessageArgsForCall []struct {
	}
	uniqueValidationErrorMessageReturns struct {
		result1 string
	}
	uniqueValidationErrorMessageReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *UniqueClientObject) DeepCopyObject() runtime.Object {
	fake.deepCopyObjectMutex.Lock()
	ret, specificReturn := fake.deepCopyObjectReturnsOnCall[len(fake.deepCopyObjectArgsForCall)]
	fake.deepCopyObjectArgsForCall = append(fake.deepCopyObjectArgsForCall, struct {
	}{})
	stub := fake.DeepCopyObjectStub
	fakeReturns := fake.deepCopyObjectReturns
	fake.recordInvocation("DeepCopyObject", []interface{}{})
	fake.deepCopyObjectMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) DeepCopyObjectCallCount() int {
	fake.deepCopyObjectMutex.RLock()
	defer fake.deepCopyObjectMutex.RUnlock()
	return len(fake.deepCopyObjectArgsForCall)
}

func (fake *UniqueClientObject) DeepCopyObjectCalls(stub func() runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = stub
}

func (fake *UniqueClientObject) DeepCopyObjectReturns(result1 runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = nil
	fake.deepCopyObjectReturns = struct {
		result1 runtime.Object
	}{result1}
}

func (fake *UniqueClientObject) DeepCopyObjectReturnsOnCall(i int, result1 runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = nil
	if fake.deepCopyObjectReturnsOnCall == nil {
		fake.deepCopyObjectReturnsOnCall = make(map[int]struct {
			result1 runtime.Object
		})
	}
	fake.deepCopyObjectReturnsOnCall[i] = struct {
		result1 runtime.Object
	}{result1}
}

func (fake *UniqueClientObject) GetAnnotations() map[string]string {
	fake.getAnnotationsMutex.Lock()
	ret, specificReturn := fake.getAnnotationsReturnsOnCall[len(fake.getAnnotationsArgsForCall)]
	fake.getAnnotationsArgsForCall = append(fake.getAnnotationsArgsForCall, struct {
	}{})
	stub := fake.GetAnnotationsStub
	fakeReturns := fake.getAnnotationsReturns
	fake.recordInvocation("GetAnnotations", []interface{}{})
	fake.getAnnotationsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetAnnotationsCallCount() int {
	fake.getAnnotationsMutex.RLock()
	defer fake.getAnnotationsMutex.RUnlock()
	return len(fake.getAnnotationsArgsForCall)
}

func (fake *UniqueClientObject) GetAnnotationsCalls(stub func() map[string]string) {
	fake.getAnnotationsMutex.Lock()
	defer fake.getAnnotationsMutex.Unlock()
	fake.GetAnnotationsStub = stub
}

func (fake *UniqueClientObject) GetAnnotationsReturns(result1 map[string]string) {
	fake.getAnnotationsMutex.Lock()
	defer fake.getAnnotationsMutex.Unlock()
	fake.GetAnnotationsStub = nil
	fake.getAnnotationsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetAnnotationsReturnsOnCall(i int, result1 map[string]string) {
	fake.getAnnotationsMutex.Lock()
	defer fake.getAnnotationsMutex.Unlock()
	fake.GetAnnotationsStub = nil
	if fake.getAnnotationsReturnsOnCall == nil {
		fake.getAnnotationsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.getAnnotationsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetCreationTimestamp() v1.Time {
	fake.getCreationTimestampMutex.Lock()
	ret, specificReturn := fake.getCreationTimestampReturnsOnCall[len(fake.getCreationTimestampArgsForCall)]
	fake.getCreationTimestampArgsForCall = append(fake.getCreationTimestampArgsForCall, struct {
	}{})
	stub := fake.GetCreationTimestampStub
	fakeReturns := fake.getCreationTimestampReturns
	fake.recordInvocation("GetCreationTimestamp", []interface{}{})
	fake.getCreationTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetCreationTimestampCallCount() int {
	fake.getCreationTimestampMutex.RLock()
	defer fake.getCreationTimestampMutex.RUnlock()
	return len(fake.getCreationTimestampArgsForCall)
}

func (fake *UniqueClientObject) GetCreationTimestampCalls(stub func() v1.Time) {
	fake.getCreationTimestampMutex.Lock()
	defer fake.getCreationTimestampMutex.Unlock()
	fake.GetCreationTimestampStub = stub
}

func (fake *UniqueClientObject) GetCreationTimestampReturns(result1 v1.Time) {
	fake.getCreationTimestampMutex.Lock()
	defer fake.getCreationTimestampMutex.Unlock()
	fake.GetCreationTimestampStub = nil
	fake.getCreationTimestampReturns = struct {
		result1 v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetCreationTimestampReturnsOnCall(i int, result1 v1.Time) {
	fake.getCreationTimestampMutex.Lock()
	defer fake.getCreationTimestampMutex.Unlock()
	fake.GetCreationTimestampStub = nil
	if fake.getCreationTimestampReturnsOnCall == nil {
		fake.getCreationTimestampReturnsOnCall = make(map[int]struct {
			result1 v1.Time
		})
	}
	fake.getCreationTimestampReturnsOnCall[i] = struct {
		result1 v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSeconds() *int64 {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	ret, specificReturn := fake.getDeletionGracePeriodSecondsReturnsOnCall[len(fake.getDeletionGracePeriodSecondsArgsForCall)]
	fake.getDeletionGracePeriodSecondsArgsForCall = append(fake.getDeletionGracePeriodSecondsArgsForCall, struct {
	}{})
	stub := fake.GetDeletionGracePeriodSecondsStub
	fakeReturns := fake.getDeletionGracePeriodSecondsReturns
	fake.recordInvocation("GetDeletionGracePeriodSeconds", []interface{}{})
	fake.getDeletionGracePeriodSecondsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsCallCount() int {
	fake.getDeletionGracePeriodSecondsMutex.RLock()
	defer fake.getDeletionGracePeriodSecondsMutex.RUnlock()
	return len(fake.getDeletionGracePeriodSecondsArgsForCall)
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsCalls(stub func() *int64) {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	defer fake.getDeletionGracePeriodSecondsMutex.Unlock()
	fake.GetDeletionGracePeriodSecondsStub = stub
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsReturns(result1 *int64) {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	defer fake.getDeletionGracePeriodSecondsMutex.Unlock()
	fake.GetDeletionGracePeriodSecondsStub = nil
	fake.getDeletionGracePeriodSecondsReturns = struct {
		result1 *int64
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsReturnsOnCall(i int, result1 *int64) {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	defer fake.getDeletionGracePeriodSecondsMutex.Unlock()
	fake.GetDeletionGracePeriodSecondsStub = nil
	if fake.getDeletionGracePeriodSecondsReturnsOnCall == nil {
		fake.getDeletionGracePeriodSecondsReturnsOnCall = make(map[int]struct {
			result1 *int64
		})
	}
	fake.getDeletionGracePeriodSecondsReturnsOnCall[i] = struct {
		result1 *int64
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionTimestamp() *v1.Time {
	fake.getDeletionTimestampMutex.Lock()
	ret, specificReturn := fake.getDeletionTimestampReturnsOnCall[len(fake.getDeletionTimestampArgsForCall)]
	fake.getDeletionTimestampArgsForCall = append(fake.getDeletionTimestampArgsForCall, struct {
	}{})
	stub := fake.GetDeletionTimestampStub
	fakeReturns := fake.getDeletionTimestampReturns
	fake.recordInvocation("GetDeletionTimestamp", []interface{}{})
	fake.getDeletionTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetDeletionTimestampCallCount() int {
	fake.getDeletionTimestampMutex.RLock()
	defer fake.getDeletionTimestampMutex.RUnlock()
	return len(fake.getDeletionTimestampArgsForCall)
}

func (fake *UniqueClientObject) GetDeletionTimestampCalls(stub func() *v1.Time) {
	fake.getDeletionTimestampMutex.Lock()
	defer fake.getDeletionTimestampMutex.Unlock()
	fake.GetDeletionTimestampStub = stub
}

func (fake *UniqueClientObject) GetDeletionTimestampReturns(result1 *v1.Time) {
	fake.getDeletionTimestampMutex.Lock()
	defer fake.getDeletionTimestampMutex.Unlock()
	fake.GetDeletionTimestampStub = nil
	fake.getDeletionTimestampReturns = struct {
		result1 *v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionTimestampReturnsOnCall(i int, result1 *v1.Time) {
	fake.getDeletionTimestampMutex.Lock()
	defer fake.getDeletionTimestampMutex.Unlock()
	fake.GetDeletionTimestampStub = nil
	if fake.getDeletionTimestampReturnsOnCall == nil {
		fake.getDeletionTimestampReturnsOnCall = make(map[int]struct {
			result1 *v1.Time
		})
	}
	fake.getDeletionTimestampReturnsOnCall[i] = struct {
		result1 *v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetFinalizers() []string {
	fake.getFinalizersMutex.Lock()
	ret, specificReturn := fake.getFinalizersReturnsOnCall[len(fake.getFinalizersArgsForCall)]
	fake.getFinalizersArgsForCall = append(fake.getFinalizersArgsForCall, struct {
	}{})
	stub := fake.GetFinalizersStub
	fakeReturns := fake.getFinalizersReturns
	fake.recordInvocation("GetFinalizers", []interface{}{})
	fake.getFinalizersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetFinalizersCallCount() int {
	fake.getFinalizersMutex.RLock()
	defer fake.getFinalizersMutex.RUnlock()
	return len(fake.getFinalizersArgsForCall)
}

func (fake *UniqueClientObject) GetFinalizersCalls(stub func() []string) {
	fake.getFinalizersMutex.Lock()
	defer fake.getFinalizersMutex.Unlock()
	fake.GetFinalizersStub = stub
}

func (fake *UniqueClientObject) GetFinalizersReturns(result1 []string) {
	fake.getFinalizersMutex.Lock()
	defer fake.getFinalizersMutex.Unlock()
	fake.GetFinalizersStub = nil
	fake.getFinalizersReturns = struct {
		result1 []string
	}{result1}
}

func (fake *UniqueClientObject) GetFinalizersReturnsOnCall(i int, result1 []string) {
	fake.getFinalizersMutex.Lock()
	defer fake.getFinalizersMutex.Unlock()
	fake.GetFinalizersStub = nil
	if fake.getFinalizersReturnsOnCall == nil {
		fake.getFinalizersReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getFinalizersReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *UniqueClientObject) GetGenerateName() string {
	fake.getGenerateNameMutex.Lock()
	ret, specificReturn := fake.getGenerateNameReturnsOnCall[len(fake.getGenerateNameArgsForCall)]
	fake.getGenerateNameArgsForCall = append(fake.getGenerateNameArgsForCall, struct {
	}{})
	stub := fake.GetGenerateNameStub
	fakeReturns := fake.getGenerateNameReturns
	fake.recordInvocation("GetGenerateName", []interface{}{})
	fake.getGenerateNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetGenerateNameCallCount() int {
	fake.getGenerateNameMutex.RLock()
	defer fake.getGenerateNameMutex.RUnlock()
	return len(fake.getGenerateNameArgsForCall)
}

func (fake *UniqueClientObject) GetGenerateNameCalls(stub func() string) {
	fake.getGenerateNameMutex.Lock()
	defer fake.getGenerateNameMutex.Unlock()
	fake.GetGenerateNameStub = stub
}

func (fake *UniqueClientObject) GetGenerateNameReturns(result1 string) {
	fake.getGenerateNameMutex.Lock()
	defer fake.getGenerateNameMutex.Unlock()
	fake.GetGenerateNameStub = nil
	fake.getGenerateNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetGenerateNameReturnsOnCall(i int, result1 string) {
	fake.getGenerateNameMutex.Lock()
	defer fake.getGenerateNameMutex.Unlock()
	fake.GetGenerateNameStub = nil
	if fake.getGenerateNameReturnsOnCall == nil {
		fake.getGenerateNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getGenerateNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetGeneration() int64 {
	fake.getGenerationMutex.Lock()
	ret, specificReturn := fake.getGenerationReturnsOnCall[len(fake.getGenerationArgsForCall)]
	fake.getGenerationArgsForCall = append(fake.getGenerationArgsForCall, struct {
	}{})
	stub := fake.GetGenerationStub
	fakeReturns := fake.getGenerationReturns
	fake.recordInvocation("GetGeneration", []interface{}{})
	fake.getGenerationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetGenerationCallCount() int {
	fake.getGenerationMutex.RLock()
	defer fake.getGenerationMutex.RUnlock()
	return len(fake.getGenerationArgsForCall)
}

func (fake *UniqueClientObject) GetGenerationCalls(stub func() int64) {
	fake.getGenerationMutex.Lock()
	defer fake.getGenerationMutex.Unlock()
	fake.GetGenerationStub = stub
}

func (fake *UniqueClientObject) GetGenerationReturns(result1 int64) {
	fake.getGenerationMutex.Lock()
	defer fake.getGenerationMutex.Unlock()
	fake.GetGenerationStub = nil
	fake.getGenerationReturns = struct {
		result1 int64
	}{result1}
}

func (fake *UniqueClientObject) GetGenerationReturnsOnCall(i int, result1 int64) {
	fake.getGenerationMutex.Lock()
	defer fake.getGenerationMutex.Unlock()
	fake.GetGenerationStub = nil
	if fake.getGenerationReturnsOnCall == nil {
		fake.getGenerationReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.getGenerationReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *UniqueClientObject) GetLabels() map[string]string {
	fake.getLabelsMutex.Lock()
	ret, specificReturn := fake.getLabelsReturnsOnCall[len(fake.getLabelsArgsForCall)]
	fake.getLabelsArgsForCall = append(fake.getLabelsArgsForCall, struct {
	}{})
	stub := fake.GetLabelsStub
	fakeReturns := fake.getLabelsReturns
	fake.recordInvocation("GetLabels", []interface{}{})
	fake.getLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetLabelsCallCount() int {
	fake.getLabelsMutex.RLock()
	defer fake.getLabelsMutex.RUnlock()
	return len(fake.getLabelsArgsForCall)
}

func (fake *UniqueClientObject) GetLabelsCalls(stub func() map[string]string) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = stub
}

func (fake *UniqueClientObject) GetLabelsReturns(result1 map[string]string) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = nil
	fake.getLabelsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetLabelsReturnsOnCall(i int, result1 map[string]string) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = nil
	if fake.getLabelsReturnsOnCall == nil {
		fake.getLabelsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.getLabelsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetManagedFields() []v1.ManagedFieldsEntry {
	fake.getManagedFieldsMutex.Lock()
	ret, specificReturn := fake.getManagedFieldsReturnsOnCall[len(fake.getManagedFieldsArgsForCall)]
	fake.getManagedFieldsArgsForCall = append(fake.getManagedFieldsArgsForCall, struct {
	}{})
	stub := fake.GetManagedFieldsStub
	fakeReturns := fake.getManagedFieldsReturns
	fake.recordInvocation("GetManagedFields", []interface{}{})
	fake.getManagedFieldsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetManagedFieldsCallCount() int {
	fake.getManagedFieldsMutex.RLock()
	defer fake.getManagedFieldsMutex.RUnlock()
	return len(fake.getManagedFieldsArgsForCall)
}

func (fake *UniqueClientObject) GetManagedFieldsCalls(stub func() []v1.ManagedFieldsEntry) {
	fake.getManagedFieldsMutex.Lock()
	defer fake.getManagedFieldsMutex.Unlock()
	fake.GetManagedFieldsStub = stub
}

func (fake *UniqueClientObject) GetManagedFieldsReturns(result1 []v1.ManagedFieldsEntry) {
	fake.getManagedFieldsMutex.Lock()
	defer fake.getManagedFieldsMutex.Unlock()
	fake.GetManagedFieldsStub = nil
	fake.getManagedFieldsReturns = struct {
		result1 []v1.ManagedFieldsEntry
	}{result1}
}

func (fake *UniqueClientObject) GetManagedFieldsReturnsOnCall(i int, result1 []v1.ManagedFieldsEntry) {
	fake.getManagedFieldsMutex.Lock()
	defer fake.getManagedFieldsMutex.Unlock()
	fake.GetManagedFieldsStub = nil
	if fake.getManagedFieldsReturnsOnCall == nil {
		fake.getManagedFieldsReturnsOnCall = make(map[int]struct {
			result1 []v1.ManagedFieldsEntry
		})
	}
	fake.getManagedFieldsReturnsOnCall[i] = struct {
		result1 []v1.ManagedFieldsEntry
	}{result1}
}

func (fake *UniqueClientObject) GetName() string {
	fake.getNameMutex.Lock()
	ret, specificReturn := fake.getNameReturnsOnCall[len(fake.getNameArgsForCall)]
	fake.getNameArgsForCall = append(fake.getNameArgsForCall, struct {
	}{})
	stub := fake.GetNameStub
	fakeReturns := fake.getNameReturns
	fake.recordInvocation("GetName", []interface{}{})
	fake.getNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetNameCallCount() int {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	return len(fake.getNameArgsForCall)
}

func (fake *UniqueClientObject) GetNameCalls(stub func() string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = stub
}

func (fake *UniqueClientObject) GetNameReturns(result1 string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	fake.getNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetNameReturnsOnCall(i int, result1 string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	if fake.getNameReturnsOnCall == nil {
		fake.getNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetNamespace() string {
	fake.getNamespaceMutex.Lock()
	ret, specificReturn := fake.getNamespaceReturnsOnCall[len(fake.getNamespaceArgsForCall)]
	fake.getNamespaceArgsForCall = append(fake.getNamespaceArgsForCall, struct {
	}{})
	stub := fake.GetNamespaceStub
	fakeReturns := fake.getNamespaceReturns
	fake.recordInvocation("GetNamespace", []interface{}{})
	fake.getNamespaceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetNamespaceCallCount() int {
	fake.getNamespaceMutex.RLock()
	defer fake.getNamespaceMutex.RUnlock()
	return len(fake.getNamespaceArgsForCall)
}

func (fake *UniqueClientObject) GetNamespaceCalls(stub func() string) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = stub
}

func (fake *UniqueClientObject) GetNamespaceReturns(result1 string) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = nil
	fake.getNamespaceReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetNamespaceReturnsOnCall(i int, result1 string) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = nil
	if fake.getNamespaceReturnsOnCall == nil {
		fake.getNamespaceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNamespaceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetObjectKind() schema.ObjectKind {
	fake.getObjectKindMutex.Lock()
	ret, specificReturn := fake.getObjectKindReturnsOnCall[len(fake.getObjectKindArgsForCall)]
	fake.getObjectKindArgsForCall = append(fake.getObjectKindArgsForCall, struct {
	}{})
	stub := fake.GetObjectKindStub
	fakeReturns := fake.getObjectKindReturns
	fake.recordInvocation("GetObjectKind", []interface{}{})
	fake.getObjectKindMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetObjectKindCallCount() int {
	fake.getObjectKindMutex.RLock()
	defer fake.getObjectKindMutex.RUnlock()
	return len(fake.getObjectKindArgsForCall)
}

func (fake *UniqueClientObject) GetObjectKindCalls(stub func() schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = stub
}

func (fake *UniqueClientObject) GetObjectKindReturns(result1 schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = nil
	fake.getObjectKindReturns = struct {
		result1 schema.ObjectKind
	}{result1}
}

func (fake *UniqueClientObject) GetObjectKindReturnsOnCall(i int, result1 schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = nil
	if fake.getObjectKindReturnsOnCall == nil {
		fake.getObjectKindReturnsOnCall = make(map[int]struct {
			result1 schema.ObjectKind
		})
	}
	fake.getObjectKindReturnsOnCall[i] = struct {
		result1 schema.ObjectKind
	}{result1}
}

func (fake *UniqueClientObject) GetOwnerReferences() []v1.OwnerReference {
	fake.getOwnerReferencesMutex.Lock()
	ret, specificReturn := fake.getOwnerReferencesReturnsOnCall[len(fake.getOwnerReferencesArgsForCall)]
	fake.getOwnerReferencesArgsForCall = append(fake.getOwnerReferencesArgsForCall, struct {
	}{})
	stub := fake.GetOwnerReferencesStub
	fakeReturns := fake.getOwnerReferencesReturns
	fake.recordInvocation("GetOwnerReferences", []interface{}{})
	fake.getOwnerReferencesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetOwnerReferencesCallCount() int {
	fake.getOwnerReferencesMutex.RLock()
	defer fake.getOwnerReferencesMutex.RUnlock()
	return len(fake.getOwnerReferencesArgsForCall)
}

func (fake *UniqueClientObject) GetOwnerReferencesCalls(stub func() []v1.OwnerReference) {
	fake.getOwnerReferencesMutex.Lock()
	defer fake.getOwnerReferencesMutex.Unlock()
	fake.GetOwnerReferencesStub = stub
}

func (fake *UniqueClientObject) GetOwnerReferencesReturns(result1 []v1.OwnerReference) {
	fake.getOwnerReferencesMutex.Lock()
	defer fake.getOwnerReferencesMutex.Unlock()
	fake.GetOwnerReferencesStub = nil
	fake.getOwnerReferencesReturns = struct {
		result1 []v1.OwnerReference
	}{result1}
}

func (fake *UniqueClientObject) GetOwnerReferencesReturnsOnCall(i int, result1 []v1.OwnerReference) {
	fake.getOwnerReferencesMutex.Lock()
	defer fake.getOwnerReferencesMutex.Unlock()
	fake.GetOwnerReferencesStub = nil
	if fake.getOwnerReferencesReturnsOnCall == nil {
		fake.getOwnerReferencesReturnsOnCall = make(map[int]struct {
			result1 []v1.OwnerReference
		})
	}
	fake.getOwnerReferencesReturnsOnCall[i] = struct {
		result1 []v1.OwnerReference
	}{result1}
}

func (fake *UniqueClientObject) GetResourceVersion() string {
	fake.getResourceVersionMutex.Lock()
	ret, specificReturn := fake.getResourceVersionReturnsOnCall[len(fake.getResourceVersionArgsForCall)]
	fake.getResourceVersionArgsForCall = append(fake.getResourceVersionArgsForCall, struct {
	}{})
	stub := fake.GetResourceVersionStub
	fakeReturns := fake.getResourceVersionReturns
	fake.recordInvocation("GetResourceVersion", []interface{}{})
	fake.getResourceVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetResourceVersionCallCount() int {
	fake.getResourceVersionMutex.RLock()
	defer fake.getResourceVersionMutex.RUnlock()
	return len(fake.getResourceVersionArgsForCall)
}

func (fake *UniqueClientObject) GetResourceVersionCalls(stub func() string) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = stub
}

func (fake *UniqueClientObject) GetResourceVersionReturns(result1 string) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = nil
	fake.getResourceVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetResourceVersionReturnsOnCall(i int, result1 string) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = nil
	if fake.getResourceVersionReturnsOnCall == nil {
		fake.getResourceVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getResourceVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetSelfLink() string {
	fake.getSelfLinkMutex.Lock()
	ret, specificReturn := fake.getSelfLinkReturnsOnCall[len(fake.getSelfLinkArgsForCall)]
	fake.getSelfLinkArgsForCall = append(fake.getSelfLinkArgsForCall, struct {
	}{})
	stub := fake.GetSelfLinkStub
	fakeReturns := fake.getSelfLinkReturns
	fake.recordInvocation("GetSelfLink", []interface{}{})
	fake.getSelfLinkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetSelfLinkCallCount() int {
	fake.getSelfLinkMutex.RLock()
	defer fake.getSelfLinkMutex.RUnlock()
	return len(fake.getSelfLinkArgsForCall)
}

func (fake *UniqueClientObject) GetSelfLinkCalls(stub func() string) {
	fake.getSelfLinkMutex.Lock()
	defer fake.getSelfLinkMutex.Unlock()
	fake.GetSelfLinkStub = stub
}

func (fake *UniqueClientObject) GetSelfLinkReturns(result1 string) {
	fake.getSelfLinkMutex.Lock()
	defer fake.getSelfLinkMutex.Unlock()
	fake.GetSelfLinkStub = nil
	fake.getSelfLinkReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetSelfLinkReturnsOnCall(i int, result1 string) {
	fake.getSelfLinkMutex.Lock()
	defer fake.getSelfLinkMutex.Unlock()
	fake.GetSelfLinkStub = nil
	if fake.getSelfLinkReturnsOnCall == nil {
		fake.getSelfLinkReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getSelfLinkReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetUID() types.UID {
	fake.getUIDMutex.Lock()
	ret, specificReturn := fake.getUIDReturnsOnCall[len(fake.getUIDArgsForCall)]
	fake.getUIDArgsForCall = append(fake.getUIDArgsForCall, struct {
	}{})
	stub := fake.GetUIDStub
	fakeReturns := fake.getUIDReturns
	fake.recordInvocation("GetUID", []interface{}{})
	fake.getUIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetUIDCallCount() int {
	fake.getUIDMutex.RLock()
	defer fake.getUIDMutex.RUnlock()
	return len(fake.getUIDArgsForCall)
}

func (fake *UniqueClientObject) GetUIDCalls(stub func() types.UID) {
	fake.getUIDMutex.Lock()
	defer fake.getUIDMutex.Unlock()
	fake.GetUIDStub = stub
}

func (fake *UniqueClientObject) GetUIDReturns(result1 types.UID) {
	fake.getUIDMutex.Lock()
	defer fake.getUIDMutex.Unlock()
	fake.GetUIDStub = nil
	fake.getUIDReturns = struct {
		result1 types.UID
	}{result1}
}

func (fake *UniqueClientObject) GetUIDReturnsOnCall(i int, result1 types.UID) {
	fake.getUIDMutex.Lock()
	defer fake.getUIDMutex.Unlock()
	fake.GetUIDStub = nil
	if fake.getUIDReturnsOnCall == nil {
		fake.getUIDReturnsOnCall = make(map[int]struct {
			result1 types.UID
		})
	}
	fake.getUIDReturnsOnCall[i] = struct {
		result1 types.UID
	}{result1}
}

func (fake *UniqueClientObject) SetAnnotations(arg1 map[string]string) {
	fake.setAnnotationsMutex.Lock()
	fake.setAnnotationsArgsForCall = append(fake.setAnnotationsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.SetAnnotationsStub
	fake.recordInvocation("SetAnnotations", []interface{}{arg1})
	fake.setAnnotationsMutex.Unlock()
	if stub != nil {
		fake.SetAnnotationsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetAnnotationsCallCount() int {
	fake.setAnnotationsMutex.RLock()
	defer fake.setAnnotationsMutex.RUnlock()
	return len(fake.setAnnotationsArgsForCall)
}

func (fake *UniqueClientObject) SetAnnotationsCalls(stub func(map[string]string)) {
	fake.setAnnotationsMutex.Lock()
	defer fake.setAnnotationsMutex.Unlock()
	fake.SetAnnotationsStub = stub
}

func (fake *UniqueClientObject) SetAnnotationsArgsForCall(i int) map[string]string {
	fake.setAnnotationsMutex.RLock()
	defer fake.setAnnotationsMutex.RUnlock()
	argsForCall := fake.setAnnotationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetCreationTimestamp(arg1 v1.Time) {
	fake.setCreationTimestampMutex.Lock()
	fake.setCreationTimestampArgsForCall = append(fake.setCreationTimestampArgsForCall, struct {
		arg1 v1.Time
	}{arg1})
	stub := fake.SetCreationTimestampStub
	fake.recordInvocation("SetCreationTimestamp", []interface{}{arg1})
	fake.setCreationTimestampMutex.Unlock()
	if stub != nil {
		fake.SetCreationTimestampStub(arg1)
	}
}

func (fake *UniqueClientObject) SetCreationTimestampCallCount() int {
	fake.setCreationTimestampMutex.RLock()
	defer fake.setCreationTimestampMutex.RUnlock()
	return len(fake.setCreationTimestampArgsForCall)
}

func (fake *UniqueClientObject) SetCreationTimestampCalls(stub func(v1.Time)) {
	fake.setCreationTimestampMutex.Lock()
	defer fake.setCreationTimestampMutex.Unlock()
	fake.SetCreationTimestampStub = stub
}

func (fake *UniqueClientObject) SetCreationTimestampArgsForCall(i int) v1.Time {
	fake.setCreationTimestampMutex.RLock()
	defer fake.setCreationTimestampMutex.RUnlock()
	argsForCall := fake.setCreationTimestampArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSeconds(arg1 *int64) {
	fake.setDeletionGracePeriodSecondsMutex.Lock()
	fake.setDeletionGracePeriodSecondsArgsForCall = append(fake.setDeletionGracePeriodSecondsArgsForCall, struct {
		arg1 *int64
	}{arg1})
	stub := fake.SetDeletionGracePeriodSecondsStub
	fake.recordInvocation("SetDeletionGracePeriodSeconds", []interface{}{arg1})
	fake.setDeletionGracePeriodSecondsMutex.Unlock()
	if stub != nil {
		fake.SetDeletionGracePeriodSecondsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSecondsCallCount() int {
	fake.setDeletionGracePeriodSecondsMutex.RLock()
	defer fake.setDeletionGracePeriodSecondsMutex.RUnlock()
	return len(fake.setDeletionGracePeriodSecondsArgsForCall)
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSecondsCalls(stub func(*int64)) {
	fake.setDeletionGracePeriodSecondsMutex.Lock()
	defer fake.setDeletionGracePeriodSecondsMutex.Unlock()
	fake.SetDeletionGracePeriodSecondsStub = stub
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSecondsArgsForCall(i int) *int64 {
	fake.setDeletionGracePeriodSecondsMutex.RLock()
	defer fake.setDeletionGracePeriodSecondsMutex.RUnlock()
	argsForCall := fake.setDeletionGracePeriodSecondsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetDeletionTimestamp(arg1 *v1.Time) {
	fake.setDeletionTimestampMutex.Lock()
	fake.setDeletionTimestampArgsForCall = append(fake.setDeletionTimestampArgsForCall, struct {
		arg1 *v1.Time
	}{arg1})
	stub := fake.SetDeletionTimestampStub
	fake.recordInvocation("SetDeletionTimestamp", []interface{}{arg1})
	fake.setDeletionTimestampMutex.Unlock()
	if stub != nil {
		fake.SetDeletionTimestampStub(arg1)
	}
}

func (fake *UniqueClientObject) SetDeletionTimestampCallCount() int {
	fake.setDeletionTimestampMutex.RLock()
	defer fake.setDeletionTimestampMutex.RUnlock()
	return len(fake.setDeletionTimestampArgsForCall)
}

func (fake *UniqueClientObject) SetDeletionTimestampCalls(stub func(*v1.Time)) {
	fake.setDeletionTimestampMutex.Lock()
	defer fake.setDeletionTimestampMutex.Unlock()
	fake.SetDeletionTimestampStub = stub
}

func (fake *UniqueClientObject) SetDeletionTimestampArgsForCall(i int) *v1.Time {
	fake.setDeletionTimestampMutex.RLock()
	defer fake.setDeletionTimestampMutex.RUnlock()
	argsForCall := fake.setDeletionTimestampArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetFinalizers(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setFinalizersMutex.Lock()
	fake.setFinalizersArgsForCall = append(fake.setFinalizersArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetFinalizersStub
	fake.recordInvocation("SetFinalizers", []interface{}{arg1Copy})
	fake.setFinalizersMutex.Unlock()
	if stub != nil {
		fake.SetFinalizersStub(arg1)
	}
}

func (fake *UniqueClientObject) SetFinalizersCallCount() int {
	fake.setFinalizersMutex.RLock()
	defer fake.setFinalizersMutex.RUnlock()
	return len(fake.setFinalizersArgsForCall)
}

func (fake *UniqueClientObject) SetFinalizersCalls(stub func([]string)) {
	fake.setFinalizersMutex.Lock()
	defer fake.setFinalizersMutex.Unlock()
	fake.SetFinalizersStub = stub
}

func (fake *UniqueClientObject) SetFinalizersArgsForCall(i int) []string {
	fake.setFinalizersMutex.RLock()
	defer fake.setFinalizersMutex.RUnlock()
	argsForCall := fake.setFinalizersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetGenerateName(arg1 string) {
	fake.setGenerateNameMutex.Lock()
	fake.setGenerateNameArgsForCall = append(fake.setGenerateNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetGenerateNameStub
	fake.recordInvocation("SetGenerateName", []interface{}{arg1})
	fake.setGenerateNameMutex.Unlock()
	if stub != nil {
		fake.SetGenerateNameStub(arg1)
	}
}

func (fake *UniqueClientObject) SetGenerateNameCallCount() int {
	fake.setGenerateNameMutex.RLock()
	defer fake.setGenerateNameMutex.RUnlock()
	return len(fake.setGenerateNameArgsForCall)
}

func (fake *UniqueClientObject) SetGenerateNameCalls(stub func(string)) {
	fake.setGenerateNameMutex.Lock()
	defer fake.setGenerateNameMutex.Unlock()
	fake.SetGenerateNameStub = stub
}

func (fake *UniqueClientObject) SetGenerateNameArgsForCall(i int) string {
	fake.setGenerateNameMutex.RLock()
	defer fake.setGenerateNameMutex.RUnlock()
	argsForCall := fake.setGenerateNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetGeneration(arg1 int64) {
	fake.setGenerationMutex.Lock()
	fake.setGenerationArgsForCall = append(fake.setGenerationArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.SetGenerationStub
	fake.recordInvocation("SetGeneration", []interface{}{arg1})
	fake.setGenerationMutex.Unlock()
	if stub != nil {
		fake.SetGenerationStub(arg1)
	}
}

func (fake *UniqueClientObject) SetGenerationCallCount() int {
	fake.setGenerationMutex.RLock()
	defer fake.setGenerationMutex.RUnlock()
	return len(fake.setGenerationArgsForCall)
}

func (fake *UniqueClientObject) SetGenerationCalls(stub func(int64)) {
	fake.setGenerationMutex.Lock()
	defer fake.setGenerationMutex.Unlock()
	fake.SetGenerationStub = stub
}

func (fake *UniqueClientObject) SetGenerationArgsForCall(i int) int64 {
	fake.setGenerationMutex.RLock()
	defer fake.setGenerationMutex.RUnlock()
	argsForCall := fake.setGenerationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetLabels(arg1 map[string]string) {
	fake.setLabelsMutex.Lock()
	fake.setLabelsArgsForCall = append(fake.setLabelsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.SetLabelsStub
	fake.recordInvocation("SetLabels", []interface{}{arg1})
	fake.setLabelsMutex.Unlock()
	if stub != nil {
		fake.SetLabelsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetLabelsCallCount() int {
	fake.setLabelsMutex.RLock()
	defer fake.setLabelsMutex.RUnlock()
	return len(fake.setLabelsArgsForCall)
}

func (fake *UniqueClientObject) SetLabelsCalls(stub func(map[string]string)) {
	fake.setLabelsMutex.Lock()
	defer fake.setLabelsMutex.Unlock()
	fake.SetLabelsStub = stub
}

func (fake *UniqueClientObject) SetLabelsArgsForCall(i int) map[string]string {
	fake.setLabelsMutex.RLock()
	defer fake.setLabelsMutex.RUnlock()
	argsForCall := fake.setLabelsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetManagedFields(arg1 []v1.ManagedFieldsEntry) {
	var arg1Copy []v1.ManagedFieldsEntry
	if arg1 != nil {
		arg1Copy = make([]v1.ManagedFieldsEntry, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setManagedFieldsMutex.Lock()
	fake.setManagedFieldsArgsForCall = append(fake.setManagedFieldsArgsForCall, struct {
		arg1 []v1.ManagedFieldsEntry
	}{arg1Copy})
	stub := fake.SetManagedFieldsStub
	fake.recordInvocation("SetManagedFields", []interface{}{arg1Copy})
	fake.setManagedFieldsMutex.Unlock()
	if stub != nil {
		fake.SetManagedFieldsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetManagedFieldsCallCount() int {
	fake.setManagedFieldsMutex.RLock()
	defer fake.setManagedFieldsMutex.RUnlock()
	return len(fake.setManagedFieldsArgsForCall)
}

func (fake *UniqueClientObject) SetManagedFieldsCalls(stub func([]v1.ManagedFieldsEntry)) {
	fake.setManagedFieldsMutex.Lock()
	defer fake.setManagedFieldsMutex.Unlock()
	fake.SetManagedFieldsStub = stub
}

func (fake *UniqueClientObject) SetManagedFieldsArgsForCall(i int) []v1.ManagedFieldsEntry {
	fake.setManagedFieldsMutex.RLock()
	defer fake.setManagedFieldsMutex.RUnlock()
	argsForCall := fake.setManagedFieldsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNameStub
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if stub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *UniqueClientObject) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *UniqueClientObject) SetNameCalls(stub func(string)) {
	fake.setNameMutex.Lock()
	defer fake.setNameMutex.Unlock()
	fake.SetNameStub = stub
}

func (fake *UniqueClientObject) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	argsForCall := fake.setNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetNamespace(arg1 string) {
	fake.setNamespaceMutex.Lock()
	fake.setNamespaceArgsForCall = append(fake.setNamespaceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNamespaceStub
	fake.recordInvocation("SetNamespace", []interface{}{arg1})
	fake.setNamespaceMutex.Unlock()
	if stub != nil {
		fake.SetNamespaceStub(arg1)
	}
}

func (fake *UniqueClientObject) SetNamespaceCallCount() int {
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	return len(fake.setNamespaceArgsForCall)
}

func (fake *UniqueClientObject) SetNamespaceCalls(stub func(string)) {
	fake.setNamespaceMutex.Lock()
	defer fake.setNamespaceMutex.Unlock()
	fake.SetNamespaceStub = stub
}

func (fake *UniqueClientObject) SetNamespaceArgsForCall(i int) string {
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	argsForCall := fake.setNamespaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetOwnerReferences(arg1 []v1.OwnerReference) {
	var arg1Copy []v1.OwnerReference
	if arg1 != nil {
		arg1Copy = make([]v1.OwnerReference, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setOwnerReferencesMutex.Lock()
	fake.setOwnerReferencesArgsForCall = append(fake.setOwnerReferencesArgsForCall, struct {
		arg1 []v1.OwnerReference
	}{arg1Copy})
	stub := fake.SetOwnerReferencesStub
	fake.recordInvocation("SetOwnerReferences", []interface{}{arg1Copy})
	fake.setOwnerReferencesMutex.Unlock()
	if stub != nil {
		fake.SetOwnerReferencesStub(arg1)
	}
}

func (fake *UniqueClientObject) SetOwnerReferencesCallCount() int {
	fake.setOwnerReferencesMutex.RLock()
	defer fake.setOwnerReferencesMutex.RUnlock()
	return len(fake.setOwnerReferencesArgsForCall)
}

func (fake *UniqueClientObject) SetOwnerReferencesCalls(stub func([]v1.OwnerReference)) {
	fake.setOwnerReferencesMutex.Lock()
	defer fake.setOwnerReferencesMutex.Unlock()
	fake.SetOwnerReferencesStub = stub
}

func (fake *UniqueClientObject) SetOwnerReferencesArgsForCall(i int) []v1.OwnerReference {
	fake.setOwnerReferencesMutex.RLock()
	defer fake.setOwnerReferencesMutex.RUnlock()
	argsForCall := fake.setOwnerReferencesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetResourceVersion(arg1 string) {
	fake.setResourceVersionMutex.Lock()
	fake.setResourceVersionArgsForCall = append(fake.setResourceVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetResourceVersionStub
	fake.recordInvocation("SetResourceVersion", []interface{}{arg1})
	fake.setResourceVersionMutex.Unlock()
	if stub != nil {
		fake.SetResourceVersionStub(arg1)
	}
}

func (fake *UniqueClientObject) SetResourceVersionCallCount() int {
	fake.setResourceVersionMutex.RLock()
	defer fake.setResourceVersionMutex.RUnlock()
	return len(fake.setResourceVersionArgsForCall)
}

func (fake *UniqueClientObject) SetResourceVersionCalls(stub func(string)) {
	fake.setResourceVersionMutex.Lock()
	defer fake.setResourceVersionMutex.Unlock()
	fake.SetResourceVersionStub = stub
}

func (fake *UniqueClientObject) SetResourceVersionArgsForCall(i int) string {
	fake.setResourceVersionMutex.RLock()
	defer fake.setResourceVersionMutex.RUnlock()
	argsForCall := fake.setResourceVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetSelfLink(arg1 string) {
	fake.setSelfLinkMutex.Lock()
	fake.setSelfLinkArgsForCall = append(fake.setSelfLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetSelfLinkStub
	fake.recordInvocation("SetSelfLink", []interface{}{arg1})
	fake.setSelfLinkMutex.Unlock()
	if stub != nil {
		fake.SetSelfLinkStub(arg1)
	}
}

func (fake *UniqueClientObject) SetSelfLinkCallCount() int {
	fake.setSelfLinkMutex.RLock()
	defer fake.setSelfLinkMutex.RUnlock()
	return len(fake.setSelfLinkArgsForCall)
}

func (fake *UniqueClientObject) SetSelfLinkCalls(stub func(string)) {
	fake.setSelfLinkMutex.Lock()
	defer fake.setSelfLinkMutex.Unlock()
	fake.SetSelfLinkStub = stub
}

func (fake *UniqueClientObject) SetSelfLinkArgsForCall(i int) string {
	fake.setSelfLinkMutex.RLock()
	defer fake.setSelfLinkMutex.RUnlock()
	argsForCall := fake.setSelfLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetUID(arg1 types.UID) {
	fake.setUIDMutex.Lock()
	fake.setUIDArgsForCall = append(fake.setUIDArgsForCall, struct {
		arg1 types.UID
	}{arg1})
	stub := fake.SetUIDStub
	fake.recordInvocation("SetUID", []interface{}{arg1})
	fake.setUIDMutex.Unlock()
	if stub != nil {
		fake.SetUIDStub(arg1)
	}
}

func (fake *UniqueClientObject) SetUIDCallCount() int {
	fake.setUIDMutex.RLock()
	defer fake.setUIDMutex.RUnlock()
	return len(fake.setUIDArgsForCall)
}

func (fake *UniqueClientObject) SetUIDCalls(stub func(types.UID)) {
	fake.setUIDMutex.Lock()
	defer fake.setUIDMutex.Unlock()
	fake.SetUIDStub = stub
}

func (fake *UniqueClientObject) SetUIDArgsForCall(i int) types.UID {
	fake.setUIDMutex.RLock()
	defer fake.setUIDMutex.RUnlock()
	argsForCall := fake.setUIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) UniqueName() string {
	fake.uniqueNameMutex.Lock()
	ret, specificReturn := fake.uniqueNameReturnsOnCall[len(fake.uniqueNameArgsForCall)]
	fake.uniqueNameArgsForCall = append(fake.uniqueNameArgsForCall, struct {
	}{})
	stub := fake.UniqueNameStub
	fakeReturns := fake.uniqueNameReturns
	fake.recordInvocation("UniqueName", []interface{}{})
	fake.uniqueNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) UniqueNameCallCount() int {
	fake.uniqueNameMutex.RLock()
	defer fake.uniqueNameMutex.RUnlock()
	return len(fake.uniqueNameArgsForCall)
}

func (fake *UniqueClientObject) UniqueNameCalls(stub func() string) {
	fake.uniqueNameMutex.Lock()
	defer fake.uniqueNameMutex.Unlock()
	fake.UniqueNameStub = stub
}

func (fake *UniqueClientObject) UniqueNameReturns(result1 string) {
	fake.uniqueNameMutex.Lock()
	defer fake.uniqueNameMutex.Unlock()
	fake.UniqueNameStub = nil
	fake.uniqueNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) UniqueNameReturnsOnCall(i int, result1 string) {
	fake.uniqueNameMutex.Lock()
	defer fake.uniqueNameMutex.Unlock()
	fake.UniqueNameStub = nil
	if fake.uniqueNameReturnsOnCall == nil {
		fake.uniqueNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uniqueNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) UniqueValidationErrorMessage() string {
	fake.uniqueValidationErrorMessageMutex.Lock()
	ret, specificReturn := fake.uniqueValidationErrorMessageReturnsOnCall[len(fake.uniqueValidationErrorMessageArgsForCall)]
	fake.uniqueValidationErrorMessageArgsForCall = append(fake.uniqueValidationErrorMessageArgsForCall, struct {
	}{})
	stub := fake.UniqueValidationErrorMessageStub
	fakeReturns := fake.uniqueValidationErrorMessageReturns
	fake.recordInvocation("UniqueValidationErrorMessage", []interface{}{})
	fake.uniqueValidationErrorMessageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageCallCount() int {
	fake.uniqueValidationErrorMessageMutex.RLock()
	defer fake.uniqueValidationErrorMessageMutex.RUnlock()
	return len(fake.uniqueValidationErrorMessageArgsForCall)
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageCalls(stub func() string) {
	fake.uniqueValidationErrorMessageMutex.Lock()
	defer fake.uniqueValidationErrorMessageMutex.Unlock()
	fake.UniqueValidationErrorMessageStub = stub
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageReturns(result1 string) {
	fake.uniqueValidationErrorMessageMutex.Lock()
	defer fake.uniqueValidationErrorMessageMutex.Unlock()
	fake.UniqueValidationErrorMessageStub = nil
	fake.uniqueValidationErrorMessageReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageReturnsOnCall(i int, result1 string) {
	fake.uniqueValidationErrorMessageMutex.Lock()
	defer fake.uniqueValidationErrorMessageMutex.Unlock()
	fake.UniqueValidationErrorMessageStub = nil
	if fake.uniqueValidationErrorMessageReturnsOnCall == nil {
		fake.uniqueValidationErrorMessageReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uniqueValidationErrorMessageReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deepCopyObjectMutex.RLock()
	defer fake.deepCopyObjectMutex.RUnlock()
	fake.getAnnotationsMutex.RLock()
	defer fake.getAnnotationsMutex.RUnlock()
	fake.getCreationTimestampMutex.RLock()
	defer fake.getCreationTimestampMutex.RUnlock()
	fake.getDeletionGracePeriodSecondsMutex.RLock()
	defer fake.getDeletionGracePeriodSecondsMutex.RUnlock()
	fake.getDeletionTimestampMutex.RLock()
	defer fake.getDeletionTimestampMutex.RUnlock()
	fake.getFinalizersMutex.RLock()
	defer fake.getFinalizersMutex.RUnlock()
	fake.getGenerateNameMutex.RLock()
	defer fake.getGenerateNameMutex.RUnlock()
	fake.getGenerationMutex.RLock()
	defer fake.getGenerationMutex.RUnlock()
	fake.getLabelsMutex.RLock()
	defer fake.getLabelsMutex.RUnlock()
	fake.getManagedFieldsMutex.RLock()
	defer fake.getManagedFieldsMutex.RUnlock()
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	fake.getNamespaceMutex.RLock()
	defer fake.getNamespaceMutex.RUnlock()
	fake.getObjectKindMutex.RLock()
	defer fake.getObjectKindMutex.RUnlock()
	fake.getOwnerReferencesMutex.RLock()
	defer fake.getOwnerReferencesMutex.RUnlock()
	fake.getResourceVersionMutex.RLock()
	defer fake.getResourceVersionMutex.RUnlock()
	fake.getSelfLinkMutex.RLock()
	defer fake.getSelfLinkMutex.RUnlock()
	fake.getUIDMutex.RLock()
	defer fake.getUIDMutex.RUnlock()
	fake.setAnnotationsMutex.RLock()
	defer fake.setAnnotationsMutex.RUnlock()
	fake.setCreationTimestampMutex.RLock()
	defer fake.setCreationTimestampMutex.RUnlock()
	fake.setDeletionGracePeriodSecondsMutex.RLock()
	defer fake.setDeletionGracePeriodSecondsMutex.RUnlock()
	fake.setDeletionTimestampMutex.RLock()
	defer fake.setDeletionTimestampMutex.RUnlock()
	fake.setFinalizersMutex.RLock()
	defer fake.setFinalizersMutex.RUnlock()
	fake.setGenerateNameMutex.RLock()
	defer fake.setGenerateNameMutex.RUnlock()
	fake.setGenerationMutex.RLock()
	defer fake.setGenerationMutex.RUnlock()
	fake.setLabelsMutex.RLock()
	defer fake.setLabelsMutex.RUnlock()
	fake.setManagedFieldsMutex.RLock()
	defer fake.setManagedFieldsMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	fake.setOwnerReferencesMutex.RLock()
	defer fake.setOwnerReferencesMutex.RUnlock()
	fake.setResourceVersionMutex.RLock()
	defer fake.setResourceVersionMutex.RUnlock()
	fake.setSelfLinkMutex.RLock()
	defer fake.setSelfLinkMutex.RUnlock()
	fake.setUIDMutex.RLock()
	defer fake.setUIDMutex.RUnlock()
	fake.uniqueNameMutex.RLock()
	defer fake.uniqueNameMutex.RUnlock()
	fake.uniqueValidationErrorMessageMutex.RLock()
	defer fake.uniqueValidationErrorMessageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *UniqueClientObject) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ webhooks.UniqueClientObject = new(UniqueClientObject)
