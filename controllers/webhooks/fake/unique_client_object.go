// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"code.cloudfoundry.org/korifi/controllers/webhooks"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
)

type UniqueClientObject struct {
	DeepCopyObjectStub        func() runtime.Object
	deepCopyObjectMutex       sync.RWMutex
	deepCopyObjectArgsForCall []struct {
	}
	deepCopyObjectReturns struct {
		result1 runtime.Object
	}
	deepCopyObjectReturnsOnCall map[int]struct {
		result1 runtime.Object
	}
	GetAnnotationsStub        func() map[string]string
	getAnnotationsMutex       sync.RWMutex
	getAnnotationsArgsForCall []struct {
	}
	getAnnotationsReturns struct {
		result1 map[string]string
	}
	getAnnotationsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	GetCreationTimestampStub        func() v1.Time
	getCreationTimestampMutex       sync.RWMutex
	getCreationTimestampArgsForCall []struct {
	}
	getCreationTimestampReturns struct {
		result1 v1.Time
	}
	getCreationTimestampReturnsOnCall map[int]struct {
		result1 v1.Time
	}
	GetDeletionGracePeriodSecondsStub        func() *int64
	getDeletionGracePeriodSecondsMutex       sync.RWMutex
	getDeletionGracePeriodSecondsArgsForCall []struct {
	}
	getDeletionGracePeriodSecondsReturns struct {
		result1 *int64
	}
	getDeletionGracePeriodSecondsReturnsOnCall map[int]struct {
		result1 *int64
	}
	GetDeletionTimestampStub        func() *v1.Time
	getDeletionTimestampMutex       sync.RWMutex
	getDeletionTimestampArgsForCall []struct {
	}
	getDeletionTimestampReturns struct {
		result1 *v1.Time
	}
	getDeletionTimestampReturnsOnCall map[int]struct {
		result1 *v1.Time
	}
	GetFinalizersStub        func() []string
	getFinalizersMutex       sync.RWMutex
	getFinalizersArgsForCall []struct {
	}
	getFinalizersReturns struct {
		result1 []string
	}
	getFinalizersReturnsOnCall map[int]struct {
		result1 []string
	}
	GetGenerateNameStub        func() string
	getGenerateNameMutex       sync.RWMutex
	getGenerateNameArgsForCall []struct {
	}
	getGenerateNameReturns struct {
		result1 string
	}
	getGenerateNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetGenerationStub        func() int64
	getGenerationMutex       sync.RWMutex
	getGenerationArgsForCall []struct {
	}
	getGenerationReturns struct {
		result1 int64
	}
	getGenerationReturnsOnCall map[int]struct {
		result1 int64
	}
	GetLabelsStub        func() map[string]string
	getLabelsMutex       sync.RWMutex
	getLabelsArgsForCall []struct {
	}
	getLabelsReturns struct {
		result1 map[string]string
	}
	getLabelsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	GetManagedFieldsStub        func() []v1.ManagedFieldsEntry
	getManagedFieldsMutex       sync.RWMutex
	getManagedFieldsArgsForCall []struct {
	}
	getManagedFieldsReturns struct {
		result1 []v1.ManagedFieldsEntry
	}
	getManagedFieldsReturnsOnCall map[int]struct {
		result1 []v1.ManagedFieldsEntry
	}
	GetNameStub        func() string
	getNameMutex       sync.RWMutex
	getNameArgsForCall []struct {
	}
	getNameReturns struct {
		result1 string
	}
	getNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetNamespaceStub        func() string
	getNamespaceMutex       sync.RWMutex
	getNamespaceArgsForCall []struct {
	}
	getNamespaceReturns struct {
		result1 string
	}
	getNamespaceReturnsOnCall map[int]struct {
		result1 string
	}
	GetObjectKindStub        func() schema.ObjectKind
	getObjectKindMutex       sync.RWMutex
	getObjectKindArgsForCall []struct {
	}
	getObjectKindReturns struct {
		result1 schema.ObjectKind
	}
	getObjectKindReturnsOnCall map[int]struct {
		result1 schema.ObjectKind
	}
	GetOwnerReferencesStub        func() []v1.OwnerReference
	getOwnerReferencesMutex       sync.RWMutex
	getOwnerReferencesArgsForCall []struct {
	}
	getOwnerReferencesReturns struct {
		result1 []v1.OwnerReference
	}
	getOwnerReferencesReturnsOnCall map[int]struct {
		result1 []v1.OwnerReference
	}
	GetResourceVersionStub        func() string
	getResourceVersionMutex       sync.RWMutex
	getResourceVersionArgsForCall []struct {
	}
	getResourceVersionReturns struct {
		result1 string
	}
	getResourceVersionReturnsOnCall map[int]struct {
		result1 string
	}
	GetSelfLinkStub        func() string
	getSelfLinkMutex       sync.RWMutex
	getSelfLinkArgsForCall []struct {
	}
	getSelfLinkReturns struct {
		result1 string
	}
	getSelfLinkReturnsOnCall map[int]struct {
		result1 string
	}
	GetUIDStub        func() types.UID
	getUIDMutex       sync.RWMutex
	getUIDArgsForCall []struct {
	}
	getUIDReturns struct {
		result1 types.UID
	}
	getUIDReturnsOnCall map[int]struct {
		result1 types.UID
	}
	SetAnnotationsStub        func(map[string]string)
	setAnnotationsMutex       sync.RWMutex
	setAnnotationsArgsForCall []struct {
		arg1 map[string]string
	}
	SetCreationTimestampStub        func(v1.Time)
	setCreationTimestampMutex       sync.RWMutex
	setCreationTimestampArgsForCall []struct {
		arg1 v1.Time
	}
	SetDeletionGracePeriodSecondsStub        func(*int64)
	setDeletionGracePeriodSecondsMutex       sync.RWMutex
	setDeletionGracePeriodSecondsArgsForCall []struct {
		arg1 *int64
	}
	SetDeletionTimestampStub        func(*v1.Time)
	setDeletionTimestampMutex       sync.RWMutex
	setDeletionTimestampArgsForCall []struct {
		arg1 *v1.Time
	}
	SetFinalizersStub        func([]string)
	setFinalizersMutex       sync.RWMutex
	setFinalizersArgsForCall []struct {
		arg1 []string
	}
	SetGenerateNameStub        func(string)
	setGenerateNameMutex       sync.RWMutex
	setGenerateNameArgsForCall []struct {
		arg1 string
	}
	SetGenerationStub        func(int64)
	setGenerationMutex       sync.RWMutex
	setGenerationArgsForCall []struct {
		arg1 int64
	}
	SetLabelsStub        func(map[string]string)
	setLabelsMutex       sync.RWMutex
	setLabelsArgsForCall []struct {
		arg1 map[string]string
	}
	SetManagedFieldsStub        func([]v1.ManagedFieldsEntry)
	setManagedFieldsMutex       sync.RWMutex
	setManagedFieldsArgsForCall []struct {
		arg1 []v1.ManagedFieldsEntry
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetNamespaceStub        func(string)
	setNamespaceMutex       sync.RWMutex
	setNamespaceArgsForCall []struct {
		arg1 string
	}
	SetOwnerReferencesStub        func([]v1.OwnerReference)
	setOwnerReferencesMutex       sync.RWMutex
	setOwnerReferencesArgsForCall []struct {
		arg1 []v1.OwnerReference
	}
	SetResourceVersionStub        func(string)
	setResourceVersionMutex       sync.RWMutex
	setResourceVersionArgsForCall []struct {
		arg1 string
	}
	SetSelfLinkStub        func(string)
	setSelfLinkMutex       sync.RWMutex
	setSelfLinkArgsForCall []struct {
		arg1 string
	}
	SetUIDStub        func(types.UID)
	setUIDMutex       sync.RWMutex
	setUIDArgsForCall []struct {
		arg1 types.UID
	}
	UniqueNameStub        func() string
	uniqueNameMutex       sync.RWMutex
	uniqueNameArgsForCall []struct {
	}
	uniqueNameReturns struct {
		result1 string
	}
	uniqueNameReturnsOnCall map[int]struct {
		result1 string
	}
	UniqueValidationErrorMessageStub        func() string
	uniqueValidationErrorMessageMutex       sync.RWMutex
	uniqueValidationErrorMessageArgsForCall []struct {
	}
	uniqueValidationErrorMessageReturns struct {
		result1 string
	}
	uniqueValidationErrorMessageReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *UniqueClientObject) DeepCopyObject() runtime.Object {
	fake.deepCopyObjectMutex.Lock()
	ret, specificReturn := fake.deepCopyObjectReturnsOnCall[len(fake.deepCopyObjectArgsForCall)]
	fake.deepCopyObjectArgsForCall = append(fake.deepCopyObjectArgsForCall, struct {
	}{})
	stub := fake.DeepCopyObjectStub
	fakeReturns := fake.deepCopyObjectReturns
	fake.recordInvocation("DeepCopyObject", []interface{}{})
	fake.deepCopyObjectMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) DeepCopyObjectCallCount() int {
	fake.deepCopyObjectMutex.RLock()
	defer fake.deepCopyObjectMutex.RUnlock()
	return len(fake.deepCopyObjectArgsForCall)
}

func (fake *UniqueClientObject) DeepCopyObjectCalls(stub func() runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = stub
}

func (fake *UniqueClientObject) DeepCopyObjectReturns(result1 runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = nil
	fake.deepCopyObjectReturns = struct {
		result1 runtime.Object
	}{result1}
}

func (fake *UniqueClientObject) DeepCopyObjectReturnsOnCall(i int, result1 runtime.Object) {
	fake.deepCopyObjectMutex.Lock()
	defer fake.deepCopyObjectMutex.Unlock()
	fake.DeepCopyObjectStub = nil
	if fake.deepCopyObjectReturnsOnCall == nil {
		fake.deepCopyObjectReturnsOnCall = make(map[int]struct {
			result1 runtime.Object
		})
	}
	fake.deepCopyObjectReturnsOnCall[i] = struct {
		result1 runtime.Object
	}{result1}
}

func (fake *UniqueClientObject) GetAnnotations() map[string]string {
	fake.getAnnotationsMutex.Lock()
	ret, specificReturn := fake.getAnnotationsReturnsOnCall[len(fake.getAnnotationsArgsForCall)]
	fake.getAnnotationsArgsForCall = append(fake.getAnnotationsArgsForCall, struct {
	}{})
	stub := fake.GetAnnotationsStub
	fakeReturns := fake.getAnnotationsReturns
	fake.recordInvocation("GetAnnotations", []interface{}{})
	fake.getAnnotationsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetAnnotationsCallCount() int {
	fake.getAnnotationsMutex.RLock()
	defer fake.getAnnotationsMutex.RUnlock()
	return len(fake.getAnnotationsArgsForCall)
}

func (fake *UniqueClientObject) GetAnnotationsCalls(stub func() map[string]string) {
	fake.getAnnotationsMutex.Lock()
	defer fake.getAnnotationsMutex.Unlock()
	fake.GetAnnotationsStub = stub
}

func (fake *UniqueClientObject) GetAnnotationsReturns(result1 map[string]string) {
	fake.getAnnotationsMutex.Lock()
	defer fake.getAnnotationsMutex.Unlock()
	fake.GetAnnotationsStub = nil
	fake.getAnnotationsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetAnnotationsReturnsOnCall(i int, result1 map[string]string) {
	fake.getAnnotationsMutex.Lock()
	defer fake.getAnnotationsMutex.Unlock()
	fake.GetAnnotationsStub = nil
	if fake.getAnnotationsReturnsOnCall == nil {
		fake.getAnnotationsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.getAnnotationsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetCreationTimestamp() v1.Time {
	fake.getCreationTimestampMutex.Lock()
	ret, specificReturn := fake.getCreationTimestampReturnsOnCall[len(fake.getCreationTimestampArgsForCall)]
	fake.getCreationTimestampArgsForCall = append(fake.getCreationTimestampArgsForCall, struct {
	}{})
	stub := fake.GetCreationTimestampStub
	fakeReturns := fake.getCreationTimestampReturns
	fake.recordInvocation("GetCreationTimestamp", []interface{}{})
	fake.getCreationTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetCreationTimestampCallCount() int {
	fake.getCreationTimestampMutex.RLock()
	defer fake.getCreationTimestampMutex.RUnlock()
	return len(fake.getCreationTimestampArgsForCall)
}

func (fake *UniqueClientObject) GetCreationTimestampCalls(stub func() v1.Time) {
	fake.getCreationTimestampMutex.Lock()
	defer fake.getCreationTimestampMutex.Unlock()
	fake.GetCreationTimestampStub = stub
}

func (fake *UniqueClientObject) GetCreationTimestampReturns(result1 v1.Time) {
	fake.getCreationTimestampMutex.Lock()
	defer fake.getCreationTimestampMutex.Unlock()
	fake.GetCreationTimestampStub = nil
	fake.getCreationTimestampReturns = struct {
		result1 v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetCreationTimestampReturnsOnCall(i int, result1 v1.Time) {
	fake.getCreationTimestampMutex.Lock()
	defer fake.getCreationTimestampMutex.Unlock()
	fake.GetCreationTimestampStub = nil
	if fake.getCreationTimestampReturnsOnCall == nil {
		fake.getCreationTimestampReturnsOnCall = make(map[int]struct {
			result1 v1.Time
		})
	}
	fake.getCreationTimestampReturnsOnCall[i] = struct {
		result1 v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSeconds() *int64 {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	ret, specificReturn := fake.getDeletionGracePeriodSecondsReturnsOnCall[len(fake.getDeletionGracePeriodSecondsArgsForCall)]
	fake.getDeletionGracePeriodSecondsArgsForCall = append(fake.getDeletionGracePeriodSecondsArgsForCall, struct {
	}{})
	stub := fake.GetDeletionGracePeriodSecondsStub
	fakeReturns := fake.getDeletionGracePeriodSecondsReturns
	fake.recordInvocation("GetDeletionGracePeriodSeconds", []interface{}{})
	fake.getDeletionGracePeriodSecondsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsCallCount() int {
	fake.getDeletionGracePeriodSecondsMutex.RLock()
	defer fake.getDeletionGracePeriodSecondsMutex.RUnlock()
	return len(fake.getDeletionGracePeriodSecondsArgsForCall)
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsCalls(stub func() *int64) {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	defer fake.getDeletionGracePeriodSecondsMutex.Unlock()
	fake.GetDeletionGracePeriodSecondsStub = stub
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsReturns(result1 *int64) {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	defer fake.getDeletionGracePeriodSecondsMutex.Unlock()
	fake.GetDeletionGracePeriodSecondsStub = nil
	fake.getDeletionGracePeriodSecondsReturns = struct {
		result1 *int64
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionGracePeriodSecondsReturnsOnCall(i int, result1 *int64) {
	fake.getDeletionGracePeriodSecondsMutex.Lock()
	defer fake.getDeletionGracePeriodSecondsMutex.Unlock()
	fake.GetDeletionGracePeriodSecondsStub = nil
	if fake.getDeletionGracePeriodSecondsReturnsOnCall == nil {
		fake.getDeletionGracePeriodSecondsReturnsOnCall = make(map[int]struct {
			result1 *int64
		})
	}
	fake.getDeletionGracePeriodSecondsReturnsOnCall[i] = struct {
		result1 *int64
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionTimestamp() *v1.Time {
	fake.getDeletionTimestampMutex.Lock()
	ret, specificReturn := fake.getDeletionTimestampReturnsOnCall[len(fake.getDeletionTimestampArgsForCall)]
	fake.getDeletionTimestampArgsForCall = append(fake.getDeletionTimestampArgsForCall, struct {
	}{})
	stub := fake.GetDeletionTimestampStub
	fakeReturns := fake.getDeletionTimestampReturns
	fake.recordInvocation("GetDeletionTimestamp", []interface{}{})
	fake.getDeletionTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetDeletionTimestampCallCount() int {
	fake.getDeletionTimestampMutex.RLock()
	defer fake.getDeletionTimestampMutex.RUnlock()
	return len(fake.getDeletionTimestampArgsForCall)
}

func (fake *UniqueClientObject) GetDeletionTimestampCalls(stub func() *v1.Time) {
	fake.getDeletionTimestampMutex.Lock()
	defer fake.getDeletionTimestampMutex.Unlock()
	fake.GetDeletionTimestampStub = stub
}

func (fake *UniqueClientObject) GetDeletionTimestampReturns(result1 *v1.Time) {
	fake.getDeletionTimestampMutex.Lock()
	defer fake.getDeletionTimestampMutex.Unlock()
	fake.GetDeletionTimestampStub = nil
	fake.getDeletionTimestampReturns = struct {
		result1 *v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetDeletionTimestampReturnsOnCall(i int, result1 *v1.Time) {
	fake.getDeletionTimestampMutex.Lock()
	defer fake.getDeletionTimestampMutex.Unlock()
	fake.GetDeletionTimestampStub = nil
	if fake.getDeletionTimestampReturnsOnCall == nil {
		fake.getDeletionTimestampReturnsOnCall = make(map[int]struct {
			result1 *v1.Time
		})
	}
	fake.getDeletionTimestampReturnsOnCall[i] = struct {
		result1 *v1.Time
	}{result1}
}

func (fake *UniqueClientObject) GetFinalizers() []string {
	fake.getFinalizersMutex.Lock()
	ret, specificReturn := fake.getFinalizersReturnsOnCall[len(fake.getFinalizersArgsForCall)]
	fake.getFinalizersArgsForCall = append(fake.getFinalizersArgsForCall, struct {
	}{})
	stub := fake.GetFinalizersStub
	fakeReturns := fake.getFinalizersReturns
	fake.recordInvocation("GetFinalizers", []interface{}{})
	fake.getFinalizersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetFinalizersCallCount() int {
	fake.getFinalizersMutex.RLock()
	defer fake.getFinalizersMutex.RUnlock()
	return len(fake.getFinalizersArgsForCall)
}

func (fake *UniqueClientObject) GetFinalizersCalls(stub func() []string) {
	fake.getFinalizersMutex.Lock()
	defer fake.getFinalizersMutex.Unlock()
	fake.GetFinalizersStub = stub
}

func (fake *UniqueClientObject) GetFinalizersReturns(result1 []string) {
	fake.getFinalizersMutex.Lock()
	defer fake.getFinalizersMutex.Unlock()
	fake.GetFinalizersStub = nil
	fake.getFinalizersReturns = struct {
		result1 []string
	}{result1}
}

func (fake *UniqueClientObject) GetFinalizersReturnsOnCall(i int, result1 []string) {
	fake.getFinalizersMutex.Lock()
	defer fake.getFinalizersMutex.Unlock()
	fake.GetFinalizersStub = nil
	if fake.getFinalizersReturnsOnCall == nil {
		fake.getFinalizersReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getFinalizersReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *UniqueClientObject) GetGenerateName() string {
	fake.getGenerateNameMutex.Lock()
	ret, specificReturn := fake.getGenerateNameReturnsOnCall[len(fake.getGenerateNameArgsForCall)]
	fake.getGenerateNameArgsForCall = append(fake.getGenerateNameArgsForCall, struct {
	}{})
	stub := fake.GetGenerateNameStub
	fakeReturns := fake.getGenerateNameReturns
	fake.recordInvocation("GetGenerateName", []interface{}{})
	fake.getGenerateNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetGenerateNameCallCount() int {
	fake.getGenerateNameMutex.RLock()
	defer fake.getGenerateNameMutex.RUnlock()
	return len(fake.getGenerateNameArgsForCall)
}

func (fake *UniqueClientObject) GetGenerateNameCalls(stub func() string) {
	fake.getGenerateNameMutex.Lock()
	defer fake.getGenerateNameMutex.Unlock()
	fake.GetGenerateNameStub = stub
}

func (fake *UniqueClientObject) GetGenerateNameReturns(result1 string) {
	fake.getGenerateNameMutex.Lock()
	defer fake.getGenerateNameMutex.Unlock()
	fake.GetGenerateNameStub = nil
	fake.getGenerateNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetGenerateNameReturnsOnCall(i int, result1 string) {
	fake.getGenerateNameMutex.Lock()
	defer fake.getGenerateNameMutex.Unlock()
	fake.GetGenerateNameStub = nil
	if fake.getGenerateNameReturnsOnCall == nil {
		fake.getGenerateNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getGenerateNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetGeneration() int64 {
	fake.getGenerationMutex.Lock()
	ret, specificReturn := fake.getGenerationReturnsOnCall[len(fake.getGenerationArgsForCall)]
	fake.getGenerationArgsForCall = append(fake.getGenerationArgsForCall, struct {
	}{})
	stub := fake.GetGenerationStub
	fakeReturns := fake.getGenerationReturns
	fake.recordInvocation("GetGeneration", []interface{}{})
	fake.getGenerationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetGenerationCallCount() int {
	fake.getGenerationMutex.RLock()
	defer fake.getGenerationMutex.RUnlock()
	return len(fake.getGenerationArgsForCall)
}

func (fake *UniqueClientObject) GetGenerationCalls(stub func() int64) {
	fake.getGenerationMutex.Lock()
	defer fake.getGenerationMutex.Unlock()
	fake.GetGenerationStub = stub
}

func (fake *UniqueClientObject) GetGenerationReturns(result1 int64) {
	fake.getGenerationMutex.Lock()
	defer fake.getGenerationMutex.Unlock()
	fake.GetGenerationStub = nil
	fake.getGenerationReturns = struct {
		result1 int64
	}{result1}
}

func (fake *UniqueClientObject) GetGenerationReturnsOnCall(i int, result1 int64) {
	fake.getGenerationMutex.Lock()
	defer fake.getGenerationMutex.Unlock()
	fake.GetGenerationStub = nil
	if fake.getGenerationReturnsOnCall == nil {
		fake.getGenerationReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.getGenerationReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *UniqueClientObject) GetLabels() map[string]string {
	fake.getLabelsMutex.Lock()
	ret, specificReturn := fake.getLabelsReturnsOnCall[len(fake.getLabelsArgsForCall)]
	fake.getLabelsArgsForCall = append(fake.getLabelsArgsForCall, struct {
	}{})
	stub := fake.GetLabelsStub
	fakeReturns := fake.getLabelsReturns
	fake.recordInvocation("GetLabels", []interface{}{})
	fake.getLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetLabelsCallCount() int {
	fake.getLabelsMutex.RLock()
	defer fake.getLabelsMutex.RUnlock()
	return len(fake.getLabelsArgsForCall)
}

func (fake *UniqueClientObject) GetLabelsCalls(stub func() map[string]string) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = stub
}

func (fake *UniqueClientObject) GetLabelsReturns(result1 map[string]string) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = nil
	fake.getLabelsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetLabelsReturnsOnCall(i int, result1 map[string]string) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = nil
	if fake.getLabelsReturnsOnCall == nil {
		fake.getLabelsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.getLabelsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *UniqueClientObject) GetManagedFields() []v1.ManagedFieldsEntry {
	fake.getManagedFieldsMutex.Lock()
	ret, specificReturn := fake.getManagedFieldsReturnsOnCall[len(fake.getManagedFieldsArgsForCall)]
	fake.getManagedFieldsArgsForCall = append(fake.getManagedFieldsArgsForCall, struct {
	}{})
	stub := fake.GetManagedFieldsStub
	fakeReturns := fake.getManagedFieldsReturns
	fake.recordInvocation("GetManagedFields", []interface{}{})
	fake.getManagedFieldsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetManagedFieldsCallCount() int {
	fake.getManagedFieldsMutex.RLock()
	defer fake.getManagedFieldsMutex.RUnlock()
	return len(fake.getManagedFieldsArgsForCall)
}

func (fake *UniqueClientObject) GetManagedFieldsCalls(stub func() []v1.ManagedFieldsEntry) {
	fake.getManagedFieldsMutex.Lock()
	defer fake.getManagedFieldsMutex.Unlock()
	fake.GetManagedFieldsStub = stub
}

func (fake *UniqueClientObject) GetManagedFieldsReturns(result1 []v1.ManagedFieldsEntry) {
	fake.getManagedFieldsMutex.Lock()
	defer fake.getManagedFieldsMutex.Unlock()
	fake.GetManagedFieldsStub = nil
	fake.getManagedFieldsReturns = struct {
		result1 []v1.ManagedFieldsEntry
	}{result1}
}

func (fake *UniqueClientObject) GetManagedFieldsReturnsOnCall(i int, result1 []v1.ManagedFieldsEntry) {
	fake.getManagedFieldsMutex.Lock()
	defer fake.getManagedFieldsMutex.Unlock()
	fake.GetManagedFieldsStub = nil
	if fake.getManagedFieldsReturnsOnCall == nil {
		fake.getManagedFieldsReturnsOnCall = make(map[int]struct {
			result1 []v1.ManagedFieldsEntry
		})
	}
	fake.getManagedFieldsReturnsOnCall[i] = struct {
		result1 []v1.ManagedFieldsEntry
	}{result1}
}

func (fake *UniqueClientObject) GetName() string {
	fake.getNameMutex.Lock()
	ret, specificReturn := fake.getNameReturnsOnCall[len(fake.getNameArgsForCall)]
	fake.getNameArgsForCall = append(fake.getNameArgsForCall, struct {
	}{})
	stub := fake.GetNameStub
	fakeReturns := fake.getNameReturns
	fake.recordInvocation("GetName", []interface{}{})
	fake.getNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetNameCallCount() int {
	fake.getNameMutex.RLock()
	defer fake.getNameMutex.RUnlock()
	return len(fake.getNameArgsForCall)
}

func (fake *UniqueClientObject) GetNameCalls(stub func() string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = stub
}

func (fake *UniqueClientObject) GetNameReturns(result1 string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	fake.getNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetNameReturnsOnCall(i int, result1 string) {
	fake.getNameMutex.Lock()
	defer fake.getNameMutex.Unlock()
	fake.GetNameStub = nil
	if fake.getNameReturnsOnCall == nil {
		fake.getNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetNamespace() string {
	fake.getNamespaceMutex.Lock()
	ret, specificReturn := fake.getNamespaceReturnsOnCall[len(fake.getNamespaceArgsForCall)]
	fake.getNamespaceArgsForCall = append(fake.getNamespaceArgsForCall, struct {
	}{})
	stub := fake.GetNamespaceStub
	fakeReturns := fake.getNamespaceReturns
	fake.recordInvocation("GetNamespace", []interface{}{})
	fake.getNamespaceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetNamespaceCallCount() int {
	fake.getNamespaceMutex.RLock()
	defer fake.getNamespaceMutex.RUnlock()
	return len(fake.getNamespaceArgsForCall)
}

func (fake *UniqueClientObject) GetNamespaceCalls(stub func() string) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = stub
}

func (fake *UniqueClientObject) GetNamespaceReturns(result1 string) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = nil
	fake.getNamespaceReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetNamespaceReturnsOnCall(i int, result1 string) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = nil
	if fake.getNamespaceReturnsOnCall == nil {
		fake.getNamespaceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNamespaceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetObjectKind() schema.ObjectKind {
	fake.getObjectKindMutex.Lock()
	ret, specificReturn := fake.getObjectKindReturnsOnCall[len(fake.getObjectKindArgsForCall)]
	fake.getObjectKindArgsForCall = append(fake.getObjectKindArgsForCall, struct {
	}{})
	stub := fake.GetObjectKindStub
	fakeReturns := fake.getObjectKindReturns
	fake.recordInvocation("GetObjectKind", []interface{}{})
	fake.getObjectKindMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetObjectKindCallCount() int {
	fake.getObjectKindMutex.RLock()
	defer fake.getObjectKindMutex.RUnlock()
	return len(fake.getObjectKindArgsForCall)
}

func (fake *UniqueClientObject) GetObjectKindCalls(stub func() schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = stub
}

func (fake *UniqueClientObject) GetObjectKindReturns(result1 schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = nil
	fake.getObjectKindReturns = struct {
		result1 schema.ObjectKind
	}{result1}
}

func (fake *UniqueClientObject) GetObjectKindReturnsOnCall(i int, result1 schema.ObjectKind) {
	fake.getObjectKindMutex.Lock()
	defer fake.getObjectKindMutex.Unlock()
	fake.GetObjectKindStub = nil
	if fake.getObjectKindReturnsOnCall == nil {
		fake.getObjectKindReturnsOnCall = make(map[int]struct {
			result1 schema.ObjectKind
		})
	}
	fake.getObjectKindReturnsOnCall[i] = struct {
		result1 schema.ObjectKind
	}{result1}
}

func (fake *UniqueClientObject) GetOwnerReferences() []v1.OwnerReference {
	fake.getOwnerReferencesMutex.Lock()
	ret, specificReturn := fake.getOwnerReferencesReturnsOnCall[len(fake.getOwnerReferencesArgsForCall)]
	fake.getOwnerReferencesArgsForCall = append(fake.getOwnerReferencesArgsForCall, struct {
	}{})
	stub := fake.GetOwnerReferencesStub
	fakeReturns := fake.getOwnerReferencesReturns
	fake.recordInvocation("GetOwnerReferences", []interface{}{})
	fake.getOwnerReferencesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetOwnerReferencesCallCount() int {
	fake.getOwnerReferencesMutex.RLock()
	defer fake.getOwnerReferencesMutex.RUnlock()
	return len(fake.getOwnerReferencesArgsForCall)
}

func (fake *UniqueClientObject) GetOwnerReferencesCalls(stub func() []v1.OwnerReference) {
	fake.getOwnerReferencesMutex.Lock()
	defer fake.getOwnerReferencesMutex.Unlock()
	fake.GetOwnerReferencesStub = stub
}

func (fake *UniqueClientObject) GetOwnerReferencesReturns(result1 []v1.OwnerReference) {
	fake.getOwnerReferencesMutex.Lock()
	defer fake.getOwnerReferencesMutex.Unlock()
	fake.GetOwnerReferencesStub = nil
	fake.getOwnerReferencesReturns = struct {
		result1 []v1.OwnerReference
	}{result1}
}

func (fake *UniqueClientObject) GetOwnerReferencesReturnsOnCall(i int, result1 []v1.OwnerReference) {
	fake.getOwnerReferencesMutex.Lock()
	defer fake.getOwnerReferencesMutex.Unlock()
	fake.GetOwnerReferencesStub = nil
	if fake.getOwnerReferencesReturnsOnCall == nil {
		fake.getOwnerReferencesReturnsOnCall = make(map[int]struct {
			result1 []v1.OwnerReference
		})
	}
	fake.getOwnerReferencesReturnsOnCall[i] = struct {
		result1 []v1.OwnerReference
	}{result1}
}

func (fake *UniqueClientObject) GetResourceVersion() string {
	fake.getResourceVersionMutex.Lock()
	ret, specificReturn := fake.getResourceVersionReturnsOnCall[len(fake.getResourceVersionArgsForCall)]
	fake.getResourceVersionArgsForCall = append(fake.getResourceVersionArgsForCall, struct {
	}{})
	stub := fake.GetResourceVersionStub
	fakeReturns := fake.getResourceVersionReturns
	fake.recordInvocation("GetResourceVersion", []interface{}{})
	fake.getResourceVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetResourceVersionCallCount() int {
	fake.getResourceVersionMutex.RLock()
	defer fake.getResourceVersionMutex.RUnlock()
	return len(fake.getResourceVersionArgsForCall)
}

func (fake *UniqueClientObject) GetResourceVersionCalls(stub func() string) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = stub
}

func (fake *UniqueClientObject) GetResourceVersionReturns(result1 string) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = nil
	fake.getResourceVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetResourceVersionReturnsOnCall(i int, result1 string) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = nil
	if fake.getResourceVersionReturnsOnCall == nil {
		fake.getResourceVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getResourceVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetSelfLink() string {
	fake.getSelfLinkMutex.Lock()
	ret, specificReturn := fake.getSelfLinkReturnsOnCall[len(fake.getSelfLinkArgsForCall)]
	fake.getSelfLinkArgsForCall = append(fake.getSelfLinkArgsForCall, struct {
	}{})
	stub := fake.GetSelfLinkStub
	fakeReturns := fake.getSelfLinkReturns
	fake.recordInvocation("GetSelfLink", []interface{}{})
	fake.getSelfLinkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetSelfLinkCallCount() int {
	fake.getSelfLinkMutex.RLock()
	defer fake.getSelfLinkMutex.RUnlock()
	return len(fake.getSelfLinkArgsForCall)
}

func (fake *UniqueClientObject) GetSelfLinkCalls(stub func() string) {
	fake.getSelfLinkMutex.Lock()
	defer fake.getSelfLinkMutex.Unlock()
	fake.GetSelfLinkStub = stub
}

func (fake *UniqueClientObject) GetSelfLinkReturns(result1 string) {
	fake.getSelfLinkMutex.Lock()
	defer fake.getSelfLinkMutex.Unlock()
	fake.GetSelfLinkStub = nil
	fake.getSelfLinkReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetSelfLinkReturnsOnCall(i int, result1 string) {
	fake.getSelfLinkMutex.Lock()
	defer fake.getSelfLinkMutex.Unlock()
	fake.GetSelfLinkStub = nil
	if fake.getSelfLinkReturnsOnCall == nil {
		fake.getSelfLinkReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getSelfLinkReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) GetUID() types.UID {
	fake.getUIDMutex.Lock()
	ret, specificReturn := fake.getUIDReturnsOnCall[len(fake.getUIDArgsForCall)]
	fake.getUIDArgsForCall = append(fake.getUIDArgsForCall, struct {
	}{})
	stub := fake.GetUIDStub
	fakeReturns := fake.getUIDReturns
	fake.recordInvocation("GetUID", []interface{}{})
	fake.getUIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) GetUIDCallCount() int {
	fake.getUIDMutex.RLock()
	defer fake.getUIDMutex.RUnlock()
	return len(fake.getUIDArgsForCall)
}

func (fake *UniqueClientObject) GetUIDCalls(stub func() types.UID) {
	fake.getUIDMutex.Lock()
	defer fake.getUIDMutex.Unlock()
	fake.GetUIDStub = stub
}

func (fake *UniqueClientObject) GetUIDReturns(result1 types.UID) {
	fake.getUIDMutex.Lock()
	defer fake.getUIDMutex.Unlock()
	fake.GetUIDStub = nil
	fake.getUIDReturns = struct {
		result1 types.UID
	}{result1}
}

func (fake *UniqueClientObject) GetUIDReturnsOnCall(i int, result1 types.UID) {
	fake.getUIDMutex.Lock()
	defer fake.getUIDMutex.Unlock()
	fake.GetUIDStub = nil
	if fake.getUIDReturnsOnCall == nil {
		fake.getUIDReturnsOnCall = make(map[int]struct {
			result1 types.UID
		})
	}
	fake.getUIDReturnsOnCall[i] = struct {
		result1 types.UID
	}{result1}
}

func (fake *UniqueClientObject) SetAnnotations(arg1 map[string]string) {
	fake.setAnnotationsMutex.Lock()
	fake.setAnnotationsArgsForCall = append(fake.setAnnotationsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.SetAnnotationsStub
	fake.recordInvocation("SetAnnotations", []interface{}{arg1})
	fake.setAnnotationsMutex.Unlock()
	if stub != nil {
		fake.SetAnnotationsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetAnnotationsCallCount() int {
	fake.setAnnotationsMutex.RLock()
	defer fake.setAnnotationsMutex.RUnlock()
	return len(fake.setAnnotationsArgsForCall)
}

func (fake *UniqueClientObject) SetAnnotationsCalls(stub func(map[string]string)) {
	fake.setAnnotationsMutex.Lock()
	defer fake.setAnnotationsMutex.Unlock()
	fake.SetAnnotationsStub = stub
}

func (fake *UniqueClientObject) SetAnnotationsArgsForCall(i int) map[string]string {
	fake.setAnnotationsMutex.RLock()
	defer fake.setAnnotationsMutex.RUnlock()
	argsForCall := fake.setAnnotationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetCreationTimestamp(arg1 v1.Time) {
	fake.setCreationTimestampMutex.Lock()
	fake.setCreationTimestampArgsForCall = append(fake.setCreationTimestampArgsForCall, struct {
		arg1 v1.Time
	}{arg1})
	stub := fake.SetCreationTimestampStub
	fake.recordInvocation("SetCreationTimestamp", []interface{}{arg1})
	fake.setCreationTimestampMutex.Unlock()
	if stub != nil {
		fake.SetCreationTimestampStub(arg1)
	}
}

func (fake *UniqueClientObject) SetCreationTimestampCallCount() int {
	fake.setCreationTimestampMutex.RLock()
	defer fake.setCreationTimestampMutex.RUnlock()
	return len(fake.setCreationTimestampArgsForCall)
}

func (fake *UniqueClientObject) SetCreationTimestampCalls(stub func(v1.Time)) {
	fake.setCreationTimestampMutex.Lock()
	defer fake.setCreationTimestampMutex.Unlock()
	fake.SetCreationTimestampStub = stub
}

func (fake *UniqueClientObject) SetCreationTimestampArgsForCall(i int) v1.Time {
	fake.setCreationTimestampMutex.RLock()
	defer fake.setCreationTimestampMutex.RUnlock()
	argsForCall := fake.setCreationTimestampArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSeconds(arg1 *int64) {
	fake.setDeletionGracePeriodSecondsMutex.Lock()
	fake.setDeletionGracePeriodSecondsArgsForCall = append(fake.setDeletionGracePeriodSecondsArgsForCall, struct {
		arg1 *int64
	}{arg1})
	stub := fake.SetDeletionGracePeriodSecondsStub
	fake.recordInvocation("SetDeletionGracePeriodSeconds", []interface{}{arg1})
	fake.setDeletionGracePeriodSecondsMutex.Unlock()
	if stub != nil {
		fake.SetDeletionGracePeriodSecondsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSecondsCallCount() int {
	fake.setDeletionGracePeriodSecondsMutex.RLock()
	defer fake.setDeletionGracePeriodSecondsMutex.RUnlock()
	return len(fake.setDeletionGracePeriodSecondsArgsForCall)
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSecondsCalls(stub func(*int64)) {
	fake.setDeletionGracePeriodSecondsMutex.Lock()
	defer fake.setDeletionGracePeriodSecondsMutex.Unlock()
	fake.SetDeletionGracePeriodSecondsStub = stub
}

func (fake *UniqueClientObject) SetDeletionGracePeriodSecondsArgsForCall(i int) *int64 {
	fake.setDeletionGracePeriodSecondsMutex.RLock()
	defer fake.setDeletionGracePeriodSecondsMutex.RUnlock()
	argsForCall := fake.setDeletionGracePeriodSecondsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetDeletionTimestamp(arg1 *v1.Time) {
	fake.setDeletionTimestampMutex.Lock()
	fake.setDeletionTimestampArgsForCall = append(fake.setDeletionTimestampArgsForCall, struct {
		arg1 *v1.Time
	}{arg1})
	stub := fake.SetDeletionTimestampStub
	fake.recordInvocation("SetDeletionTimestamp", []interface{}{arg1})
	fake.setDeletionTimestampMutex.Unlock()
	if stub != nil {
		fake.SetDeletionTimestampStub(arg1)
	}
}

func (fake *UniqueClientObject) SetDeletionTimestampCallCount() int {
	fake.setDeletionTimestampMutex.RLock()
	defer fake.setDeletionTimestampMutex.RUnlock()
	return len(fake.setDeletionTimestampArgsForCall)
}

func (fake *UniqueClientObject) SetDeletionTimestampCalls(stub func(*v1.Time)) {
	fake.setDeletionTimestampMutex.Lock()
	defer fake.setDeletionTimestampMutex.Unlock()
	fake.SetDeletionTimestampStub = stub
}

func (fake *UniqueClientObject) SetDeletionTimestampArgsForCall(i int) *v1.Time {
	fake.setDeletionTimestampMutex.RLock()
	defer fake.setDeletionTimestampMutex.RUnlock()
	argsForCall := fake.setDeletionTimestampArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetFinalizers(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setFinalizersMutex.Lock()
	fake.setFinalizersArgsForCall = append(fake.setFinalizersArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetFinalizersStub
	fake.recordInvocation("SetFinalizers", []interface{}{arg1Copy})
	fake.setFinalizersMutex.Unlock()
	if stub != nil {
		fake.SetFinalizersStub(arg1)
	}
}

func (fake *UniqueClientObject) SetFinalizersCallCount() int {
	fake.setFinalizersMutex.RLock()
	defer fake.setFinalizersMutex.RUnlock()
	return len(fake.setFinalizersArgsForCall)
}

func (fake *UniqueClientObject) SetFinalizersCalls(stub func([]string)) {
	fake.setFinalizersMutex.Lock()
	defer fake.setFinalizersMutex.Unlock()
	fake.SetFinalizersStub = stub
}

func (fake *UniqueClientObject) SetFinalizersArgsForCall(i int) []string {
	fake.setFinalizersMutex.RLock()
	defer fake.setFinalizersMutex.RUnlock()
	argsForCall := fake.setFinalizersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetGenerateName(arg1 string) {
	fake.setGenerateNameMutex.Lock()
	fake.setGenerateNameArgsForCall = append(fake.setGenerateNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetGenerateNameStub
	fake.recordInvocation("SetGenerateName", []interface{}{arg1})
	fake.setGenerateNameMutex.Unlock()
	if stub != nil {
		fake.SetGenerateNameStub(arg1)
	}
}

func (fake *UniqueClientObject) SetGenerateNameCallCount() int {
	fake.setGenerateNameMutex.RLock()
	defer fake.setGenerateNameMutex.RUnlock()
	return len(fake.setGenerateNameArgsForCall)
}

func (fake *UniqueClientObject) SetGenerateNameCalls(stub func(string)) {
	fake.setGenerateNameMutex.Lock()
	defer fake.setGenerateNameMutex.Unlock()
	fake.SetGenerateNameStub = stub
}

func (fake *UniqueClientObject) SetGenerateNameArgsForCall(i int) string {
	fake.setGenerateNameMutex.RLock()
	defer fake.setGenerateNameMutex.RUnlock()
	argsForCall := fake.setGenerateNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetGeneration(arg1 int64) {
	fake.setGenerationMutex.Lock()
	fake.setGenerationArgsForCall = append(fake.setGenerationArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.SetGenerationStub
	fake.recordInvocation("SetGeneration", []interface{}{arg1})
	fake.setGenerationMutex.Unlock()
	if stub != nil {
		fake.SetGenerationStub(arg1)
	}
}

func (fake *UniqueClientObject) SetGenerationCallCount() int {
	fake.setGenerationMutex.RLock()
	defer fake.setGenerationMutex.RUnlock()
	return len(fake.setGenerationArgsForCall)
}

func (fake *UniqueClientObject) SetGenerationCalls(stub func(int64)) {
	fake.setGenerationMutex.Lock()
	defer fake.setGenerationMutex.Unlock()
	fake.SetGenerationStub = stub
}

func (fake *UniqueClientObject) SetGenerationArgsForCall(i int) int64 {
	fake.setGenerationMutex.RLock()
	defer fake.setGenerationMutex.RUnlock()
	argsForCall := fake.setGenerationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetLabels(arg1 map[string]string) {
	fake.setLabelsMutex.Lock()
	fake.setLabelsArgsForCall = append(fake.setLabelsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.SetLabelsStub
	fake.recordInvocation("SetLabels", []interface{}{arg1})
	fake.setLabelsMutex.Unlock()
	if stub != nil {
		fake.SetLabelsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetLabelsCallCount() int {
	fake.setLabelsMutex.RLock()
	defer fake.setLabelsMutex.RUnlock()
	return len(fake.setLabelsArgsForCall)
}

func (fake *UniqueClientObject) SetLabelsCalls(stub func(map[string]string)) {
	fake.setLabelsMutex.Lock()
	defer fake.setLabelsMutex.Unlock()
	fake.SetLabelsStub = stub
}

func (fake *UniqueClientObject) SetLabelsArgsForCall(i int) map[string]string {
	fake.setLabelsMutex.RLock()
	defer fake.setLabelsMutex.RUnlock()
	argsForCall := fake.setLabelsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetManagedFields(arg1 []v1.ManagedFieldsEntry) {
	var arg1Copy []v1.ManagedFieldsEntry
	if arg1 != nil {
		arg1Copy = make([]v1.ManagedFieldsEntry, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setManagedFieldsMutex.Lock()
	fake.setManagedFieldsArgsForCall = append(fake.setManagedFieldsArgsForCall, struct {
		arg1 []v1.ManagedFieldsEntry
	}{arg1Copy})
	stub := fake.SetManagedFieldsStub
	fake.recordInvocation("SetManagedFields", []interface{}{arg1Copy})
	fake.setManagedFieldsMutex.Unlock()
	if stub != nil {
		fake.SetManagedFieldsStub(arg1)
	}
}

func (fake *UniqueClientObject) SetManagedFieldsCallCount() int {
	fake.setManagedFieldsMutex.RLock()
	defer fake.setManagedFieldsMutex.RUnlock()
	return len(fake.setManagedFieldsArgsForCall)
}

func (fake *UniqueClientObject) SetManagedFieldsCalls(stub func([]v1.ManagedFieldsEntry)) {
	fake.setManagedFieldsMutex.Lock()
	defer fake.setManagedFieldsMutex.Unlock()
	fake.SetManagedFieldsStub = stub
}

func (fake *UniqueClientObject) SetManagedFieldsArgsForCall(i int) []v1.ManagedFieldsEntry {
	fake.setManagedFieldsMutex.RLock()
	defer fake.setManagedFieldsMutex.RUnlock()
	argsForCall := fake.setManagedFieldsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNameStub
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if stub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *UniqueClientObject) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *UniqueClientObject) SetNameCalls(stub func(string)) {
	fake.setNameMutex.Lock()
	defer fake.setNameMutex.Unlock()
	fake.SetNameStub = stub
}

func (fake *UniqueClientObject) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	argsForCall := fake.setNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetNamespace(arg1 string) {
	fake.setNamespaceMutex.Lock()
	fake.setNamespaceArgsForCall = append(fake.setNamespaceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetNamespaceStub
	fake.recordInvocation("SetNamespace", []interface{}{arg1})
	fake.setNamespaceMutex.Unlock()
	if stub != nil {
		fake.SetNamespaceStub(arg1)
	}
}

func (fake *UniqueClientObject) SetNamespaceCallCount() int {
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	return len(fake.setNamespaceArgsForCall)
}

func (fake *UniqueClientObject) SetNamespaceCalls(stub func(string)) {
	fake.setNamespaceMutex.Lock()
	defer fake.setNamespaceMutex.Unlock()
	fake.SetNamespaceStub = stub
}

func (fake *UniqueClientObject) SetNamespaceArgsForCall(i int) string {
	fake.setNamespaceMutex.RLock()
	defer fake.setNamespaceMutex.RUnlock()
	argsForCall := fake.setNamespaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetOwnerReferences(arg1 []v1.OwnerReference) {
	var arg1Copy []v1.OwnerReference
	if arg1 != nil {
		arg1Copy = make([]v1.OwnerReference, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setOwnerReferencesMutex.Lock()
	fake.setOwnerReferencesArgsForCall = append(fake.setOwnerReferencesArgsForCall, struct {
		arg1 []v1.OwnerReference
	}{arg1Copy})
	stub := fake.SetOwnerReferencesStub
	fake.recordInvocation("SetOwnerReferences", []interface{}{arg1Copy})
	fake.setOwnerReferencesMutex.Unlock()
	if stub != nil {
		fake.SetOwnerReferencesStub(arg1)
	}
}

func (fake *UniqueClientObject) SetOwnerReferencesCallCount() int {
	fake.setOwnerReferencesMutex.RLock()
	defer fake.setOwnerReferencesMutex.RUnlock()
	return len(fake.setOwnerReferencesArgsForCall)
}

func (fake *UniqueClientObject) SetOwnerReferencesCalls(stub func([]v1.OwnerReference)) {
	fake.setOwnerReferencesMutex.Lock()
	defer fake.setOwnerReferencesMutex.Unlock()
	fake.SetOwnerReferencesStub = stub
}

func (fake *UniqueClientObject) SetOwnerReferencesArgsForCall(i int) []v1.OwnerReference {
	fake.setOwnerReferencesMutex.RLock()
	defer fake.setOwnerReferencesMutex.RUnlock()
	argsForCall := fake.setOwnerReferencesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetResourceVersion(arg1 string) {
	fake.setResourceVersionMutex.Lock()
	fake.setResourceVersionArgsForCall = append(fake.setResourceVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetResourceVersionStub
	fake.recordInvocation("SetResourceVersion", []interface{}{arg1})
	fake.setResourceVersionMutex.Unlock()
	if stub != nil {
		fake.SetResourceVersionStub(arg1)
	}
}

func (fake *UniqueClientObject) SetResourceVersionCallCount() int {
	fake.setResourceVersionMutex.RLock()
	defer fake.setResourceVersionMutex.RUnlock()
	return len(fake.setResourceVersionArgsForCall)
}

func (fake *UniqueClientObject) SetResourceVersionCalls(stub func(string)) {
	fake.setResourceVersionMutex.Lock()
	defer fake.setResourceVersionMutex.Unlock()
	fake.SetResourceVersionStub = stub
}

func (fake *UniqueClientObject) SetResourceVersionArgsForCall(i int) string {
	fake.setResourceVersionMutex.RLock()
	defer fake.setResourceVersionMutex.RUnlock()
	argsForCall := fake.setResourceVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetSelfLink(arg1 string) {
	fake.setSelfLinkMutex.Lock()
	fake.setSelfLinkArgsForCall = append(fake.setSelfLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetSelfLinkStub
	fake.recordInvocation("SetSelfLink", []interface{}{arg1})
	fake.setSelfLinkMutex.Unlock()
	if stub != nil {
		fake.SetSelfLinkStub(arg1)
	}
}

func (fake *UniqueClientObject) SetSelfLinkCallCount() int {
	fake.setSelfLinkMutex.RLock()
	defer fake.setSelfLinkMutex.RUnlock()
	return len(fake.setSelfLinkArgsForCall)
}

func (fake *UniqueClientObject) SetSelfLinkCalls(stub func(string)) {
	fake.setSelfLinkMutex.Lock()
	defer fake.setSelfLinkMutex.Unlock()
	fake.SetSelfLinkStub = stub
}

func (fake *UniqueClientObject) SetSelfLinkArgsForCall(i int) string {
	fake.setSelfLinkMutex.RLock()
	defer fake.setSelfLinkMutex.RUnlock()
	argsForCall := fake.setSelfLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) SetUID(arg1 types.UID) {
	fake.setUIDMutex.Lock()
	fake.setUIDArgsForCall = append(fake.setUIDArgsForCall, struct {
		arg1 types.UID
	}{arg1})
	stub := fake.SetUIDStub
	fake.recordInvocation("SetUID", []interface{}{arg1})
	fake.setUIDMutex.Unlock()
	if stub != nil {
		fake.SetUIDStub(arg1)
	}
}

func (fake *UniqueClientObject) SetUIDCallCount() int {
	fake.setUIDMutex.RLock()
	defer fake.setUIDMutex.RUnlock()
	return len(fake.setUIDArgsForCall)
}

func (fake *UniqueClientObject) SetUIDCalls(stub func(types.UID)) {
	fake.setUIDMutex.Lock()
	defer fake.setUIDMutex.Unlock()
	fake.SetUIDStub = stub
}

func (fake *UniqueClientObject) SetUIDArgsForCall(i int) types.UID {
	fake.setUIDMutex.RLock()
	defer fake.setUIDMutex.RUnlock()
	argsForCall := fake.setUIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *UniqueClientObject) UniqueName() string {
	fake.uniqueNameMutex.Lock()
	ret, specificReturn := fake.uniqueNameReturnsOnCall[len(fake.uniqueNameArgsForCall)]
	fake.uniqueNameArgsForCall = append(fake.uniqueNameArgsForCall, struct {
	}{})
	stub := fake.UniqueNameStub
	fakeReturns := fake.uniqueNameReturns
	fake.recordInvocation("UniqueName", []interface{}{})
	fake.uniqueNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) UniqueNameCallCount() int {
	fake.uniqueNameMutex.RLock()
	defer fake.uniqueNameMutex.RUnlock()
	return len(fake.uniqueNameArgsForCall)
}

func (fake *UniqueClientObject) UniqueNameCalls(stub func() string) {
	fake.uniqueNameMutex.Lock()
	defer fake.uniqueNameMutex.Unlock()
	fake.UniqueNameStub = stub
}

func (fake *UniqueClientObject) UniqueNameReturns(result1 string) {
	fake.uniqueNameMutex.Lock()
	defer fake.uniqueNameMutex.Unlock()
	fake.UniqueNameStub = nil
	fake.uniqueNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) UniqueNameReturnsOnCall(i int, result1 string) {
	fake.uniqueNameMutex.Lock()
	defer fake.uniqueNameMutex.Unlock()
	fake.UniqueNameStub = nil
	if fake.uniqueNameReturnsOnCall == nil {
		fake.uniqueNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uniqueNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) UniqueValidationErrorMessage() string {
	fake.uniqueValidationErrorMessageMutex.Lock()
	ret, specificReturn := fake.uniqueValidationErrorMessageReturnsOnCall[len(fake.uniqueValidationErrorMessageArgsForCall)]
	fake.uniqueValidationErrorMessageArgsForCall = append(fake.uniqueValidationErrorMessageArgsForCall, struct {
	}{})
	stub := fake.UniqueValidationErrorMessageStub
	fakeReturns := fake.uniqueValidationErrorMessageReturns
	fake.recordInvocation("UniqueValidationErrorMessage", []interface{}{})
	fake.uniqueValidationErrorMessageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageCallCount() int {
	fake.uniqueValidationErrorMessageMutex.RLock()
	defer fake.uniqueValidationErrorMessageMutex.RUnlock()
	return len(fake.uniqueValidationErrorMessageArgsForCall)
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageCalls(stub func() string) {
	fake.uniqueValidationErrorMessageMutex.Lock()
	defer fake.uniqueValidationErrorMessageMutex.Unlock()
	fake.UniqueValidationErrorMessageStub = stub
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageReturns(result1 string) {
	fake.uniqueValidationErrorMessageMutex.Lock()
	defer fake.uniqueValidationErrorMessageMutex.Unlock()
	fake.UniqueValidationErrorMessageStub = nil
	fake.uniqueValidationErrorMessageReturns = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) UniqueValidationErrorMessageReturnsOnCall(i int, result1 string) {
	fake.uniqueValidationErrorMessageMutex.Lock()
	defer fake.uniqueValidationErrorMessageMutex.Unlock()
	fake.UniqueValidationErrorMessageStub = nil
	if fake.uniqueValidationErrorMessageReturnsOnCall == nil {
		fake.uniqueValidationErrorMessageReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uniqueValidationErrorMessageReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *UniqueClientObject) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *UniqueClientObject) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ webhooks.UniqueClientObject = new(UniqueClientObject)
