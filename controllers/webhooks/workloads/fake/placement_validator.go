// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"code.cloudfoundry.org/korifi/controllers/apis/v1alpha1"
	"code.cloudfoundry.org/korifi/controllers/webhooks/workloads"
)

type PlacementValidator struct {
	ValidateOrgCreateStub        func(v1alpha1.CFOrg) error
	validateOrgCreateMutex       sync.RWMutex
	validateOrgCreateArgsForCall []struct {
		arg1 v1alpha1.CFOrg
	}
	validateOrgCreateReturns struct {
		result1 error
	}
	validateOrgCreateReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateSpaceCreateStub        func(v1alpha1.CFSpace) error
	validateSpaceCreateMutex       sync.RWMutex
	validateSpaceCreateArgsForCall []struct {
		arg1 v1alpha1.CFSpace
	}
	validateSpaceCreateReturns struct {
		result1 error
	}
	validateSpaceCreateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *PlacementValidator) ValidateOrgCreate(arg1 v1alpha1.CFOrg) error {
	fake.validateOrgCreateMutex.Lock()
	ret, specificReturn := fake.validateOrgCreateReturnsOnCall[len(fake.validateOrgCreateArgsForCall)]
	fake.validateOrgCreateArgsForCall = append(fake.validateOrgCreateArgsForCall, struct {
		arg1 v1alpha1.CFOrg
	}{arg1})
	stub := fake.ValidateOrgCreateStub
	fakeReturns := fake.validateOrgCreateReturns
	fake.recordInvocation("ValidateOrgCreate", []interface{}{arg1})
	fake.validateOrgCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PlacementValidator) ValidateOrgCreateCallCount() int {
	fake.validateOrgCreateMutex.RLock()
	defer fake.validateOrgCreateMutex.RUnlock()
	return len(fake.validateOrgCreateArgsForCall)
}

func (fake *PlacementValidator) ValidateOrgCreateCalls(stub func(v1alpha1.CFOrg) error) {
	fake.validateOrgCreateMutex.Lock()
	defer fake.validateOrgCreateMutex.Unlock()
	fake.ValidateOrgCreateStub = stub
}

func (fake *PlacementValidator) ValidateOrgCreateArgsForCall(i int) v1alpha1.CFOrg {
	fake.validateOrgCreateMutex.RLock()
	defer fake.validateOrgCreateMutex.RUnlock()
	argsForCall := fake.validateOrgCreateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *PlacementValidator) ValidateOrgCreateReturns(result1 error) {
	fake.validateOrgCreateMutex.Lock()
	defer fake.validateOrgCreateMutex.Unlock()
	fake.ValidateOrgCreateStub = nil
	fake.validateOrgCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *PlacementValidator) ValidateOrgCreateReturnsOnCall(i int, result1 error) {
	fake.validateOrgCreateMutex.Lock()
	defer fake.validateOrgCreateMutex.Unlock()
	fake.ValidateOrgCreateStub = nil
	if fake.validateOrgCreateReturnsOnCall == nil {
		fake.validateOrgCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateOrgCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PlacementValidator) ValidateSpaceCreate(arg1 v1alpha1.CFSpace) error {
	fake.validateSpaceCreateMutex.Lock()
	ret, specificReturn := fake.validateSpaceCreateReturnsOnCall[len(fake.validateSpaceCreateArgsForCall)]
	fake.validateSpaceCreateArgsForCall = append(fake.validateSpaceCreateArgsForCall, struct {
		arg1 v1alpha1.CFSpace
	}{arg1})
	stub := fake.ValidateSpaceCreateStub
	fakeReturns := fake.validateSpaceCreateReturns
	fake.recordInvocation("ValidateSpaceCreate", []interface{}{arg1})
	fake.validateSpaceCreateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PlacementValidator) ValidateSpaceCreateCallCount() int {
	fake.validateSpaceCreateMutex.RLock()
	defer fake.validateSpaceCreateMutex.RUnlock()
	return len(fake.validateSpaceCreateArgsForCall)
}

func (fake *PlacementValidator) ValidateSpaceCreateCalls(stub func(v1alpha1.CFSpace) error) {
	fake.validateSpaceCreateMutex.Lock()
	defer fake.validateSpaceCreateMutex.Unlock()
	fake.ValidateSpaceCreateStub = stub
}

func (fake *PlacementValidator) ValidateSpaceCreateArgsForCall(i int) v1alpha1.CFSpace {
	fake.validateSpaceCreateMutex.RLock()
	defer fake.validateSpaceCreateMutex.RUnlock()
	argsForCall := fake.validateSpaceCreateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *PlacementValidator) ValidateSpaceCreateReturns(result1 error) {
	fake.validateSpaceCreateMutex.Lock()
	defer fake.validateSpaceCreateMutex.Unlock()
	fake.ValidateSpaceCreateStub = nil
	fake.validateSpaceCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *PlacementValidator) ValidateSpaceCreateReturnsOnCall(i int, result1 error) {
	fake.validateSpaceCreateMutex.Lock()
	defer fake.validateSpaceCreateMutex.Unlock()
	fake.ValidateSpaceCreateStub = nil
	if fake.validateSpaceCreateReturnsOnCall == nil {
		fake.validateSpaceCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateSpaceCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PlacementValidator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.validateOrgCreateMutex.RLock()
	defer fake.validateOrgCreateMutex.RUnlock()
	fake.validateSpaceCreateMutex.RLock()
	defer fake.validateSpaceCreateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *PlacementValidator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ workloads.PlacementValidator = new(PlacementValidator)
